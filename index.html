<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Advanced Music Theory Tool</title>
    <style>
        :root {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --scale-color: #00ff9d;
            --root-color: #ff006e;
            --fifth-color: #8a2be2;
            --fourth-color: #FF8C00;
            --border-color: #333333;
            --hover-color: #2a2a2a;
            --key-active: #00f2ff;
        }

        body {
            font-family: 'Arial', sans-serif;
            max-width: 100%;
            margin: 0;
            padding: 10px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            box-sizing: border-box;
        }

        .container {
            display: grid;
            gap: 10px;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Top Section Styling */
        .key-info {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        @media (min-width: 768px) {
            .key-info {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .info-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: var(--bg-primary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        @media (min-width: 480px) {
            .info-item {
                flex-direction: row;
                align-items: center;
            }
        }

        .info-label {
            font-weight: bold;
            color: var(--scale-color);
            min-width: 100px;
        }

        select, input[type="number"] {
            flex: 1;
            min-height: 44px;
            padding: 8px 12px;
            font-size: 16px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            width: 100%;
        }

        @media (min-width: 480px) {
            select, input[type="number"] {
                width: auto;
            }
        }

        /* Legend Styling */
        .legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        @media (min-width: 768px) {
            .legend {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        /* Keyboard Styling */
        .keyboard-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 5px 0;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .keyboard {
            position: relative;
            height: 100px;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 10px;
            user-select: none;
            width: 490px; /* Fixed width to accommodate all keys */
            border: 1px solid var(--border-color);
            margin: 0 auto;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Container for the actual keys */
        .keyboard::after {
            content: '';
            display: block;
            clear: both;
        }

        .key {
            position: absolute;
            border: 1px solid var(--border-color);
            border-radius: 0 0 4px 4px;
            cursor: pointer;
            transition: transform 0.15s ease, background-color 0.3s ease;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .white {
            width: 35px;
            height: 100px;
            background: #ffffff;
        }

        .black {
            width: 20px;
            height: 65px;
            background: #000000;
            z-index: 1;
        }

        .key:hover {
            opacity: 0.9;
        }

        .key:active {
            transform: translateY(2px);
        }

        /* Controls Styling */
        .controls {
            display: grid;
            gap: 15px;
            margin: 20px 0;
        }

        .progression-controls {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .control-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        @media (min-width: 768px) {
            .control-group {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }

        .mode-toggles {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        @media (min-width: 768px) {
            .mode-toggles {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        .chord-count-control {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            min-height: 44px;
        }

        .chord-count-control input {
            width: 70px;
            text-align: center;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            min-height: 44px;
        }

        .toggle-switch input[type="checkbox"] {
            width: 24px;
            height: 24px;
            margin: 0;
        }

        button {
            min-height: 44px;
            padding: 12px 24px;
            font-size: 16px;
            background: var(--root-color);
            color: var(--text-primary);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .generate-button-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .key-behavior-note {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin: 15px 0;
            padding: 15px;
            border-radius: 4px;
            background: var(--bg-primary);
            text-align: center;
            border: 1px solid var(--border-color);
        }

        /* Developer Credit */
        .developer-credit {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85em;
            margin: 10px 0;
            font-style: italic;
        }

        /* Progression Output Styling */
        .progression-header {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--scale-color);
            text-align: center;
        }

        .progression-output {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid var(--border-color);
        }

        .chord-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        @media (min-width: 768px) {
            .chord-list {
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                gap: 16px;
            }
        }

        .chord-item {
            padding: 15px;
            border-radius: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            position: relative;
            min-height: 44px;
        }

        .play-chord-button {
            opacity: 1;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            min-width: 44px;
            min-height: 44px;
        }
        .play-controls-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px auto;
            text-align: center;
            max-width: 300px;
        }

        .tempo-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #tempoSelect {
            min-width: 100px;
            text-align: center;
        }

        #playProgressionBtn {
            background-color: var(--scale-color);
            min-width: 120px;
        }

        #playProgressionBtn.playing {
            background-color: var(--root-color);
        }

        .chord-item.playing {
            background-color: var(--hover-color);
            border-color: var(--scale-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="key-info">
            <div class="info-group">
                <div class="info-item">
                    <span class="info-label">Scale:</span>
                    <select id="scale"></select>
                </div>
                <div class="info-item">
                    <span class="info-label">Base Key:</span>
                    <select id="key"></select>
                </div>
            </div>

            <div class="info-group">
                <div class="info-item">
                    <span class="info-label">Up 5th Key:</span>
                    <span id="complementaryKeyInfo"></span>
                </div>
                <div class="info-item">
                    <span class="info-label">Down 4th Key:</span>
                    <span id="fourthKeyInfo"></span>
                </div>
            </div>

            <div class="info-group">
                <div class="info-item">
                    <span class="info-label">Mood:</span>
                    <select id="mood">
                        <option value="happy">Happy</option>
                        <option value="sad">Sad</option>
                        <option value="mysterious">Mysterious</option>
                        <option value="epic">Epic</option>
                        <option value="romantic">Romantic</option>
                        <option value="melancholic">Melancholic</option>
                        <option value="dreamy">Dreamy</option>
                        <option value="tense">Tense</option>
                        <option value="peaceful">Peaceful</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="developer-credit">developed by elkmire, for mabel ♥</div>

        <div class="keyboard-container">
            <div class="keyboard" id="keyboard"></div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="color-box" style="background: var(--root-color)"></div>
                <span>Root Note</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: var(--scale-color)"></div>
                <span>Scale Notes</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: var(--fifth-color)"></div>
                <span>Circle of 5ths</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: var(--fourth-color)"></div>
                <span>Circle of 4ths</span>
            </div>
        </div>

        <div class="progression">
            <div class="progression-header">Chord Progression Generator</div>
            
            <div class="progression-controls">
                <div class="mode-toggles">
                    <div class="chord-count-control">
                        <label for="chordCount">Chords:</label>
                        <input type="number" id="chordCount" min="2" max="8" value="4">
                    </div>
                    <div class="toggle-switch">
                        <input type="checkbox" id="seventhMode">
                        <label for="seventhMode">+7th Chords</label>
                    </div>
                    <div class="toggle-switch">
                        <input type="checkbox" id="advancedMode">
                        <label for="advancedMode">+ 9th/11th Chords</label>
                    </div>
                    <div class="toggle-switch">
                        <input type="checkbox" id="complexMode">
                        <label for="complexMode">Complex Mode</label>
                    </div>
                </div>
                
                <div class="key-behavior-note">
                    Note: Changing the base key will update existing progressions. Changes to scale or mood require generating a new progression.
                </div>
                
                <div class="generate-button-container">
                    <button onclick="generateProgression()">Generate Progression</button>
                </div>
            </div>
            
            <div class="progression-output">
                <div id="progressionOutput"></div>
            </div>
        </div>
    </div>

    <script>
        let audioContext = null;
        let isPlaying = false;
        let progressionInterval = null;

        const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        const SCALES = {
            'major': [0, 2, 4, 5, 7, 9, 11],
            'minor': [0, 2, 3, 5, 7, 8, 10],
            'harmonic_minor': [0, 2, 3, 5, 7, 8, 11],
            'melodic_minor': [0, 2, 3, 5, 7, 9, 11],
            'dorian': [0, 2, 3, 5, 7, 9, 10],
            'phrygian': [0, 1, 3, 5, 7, 8, 10],
            'lydian': [0, 2, 4, 6, 7, 9, 11],
            'mixolydian': [0, 2, 4, 5, 7, 9, 10],
            'locrian': [0, 1, 3, 5, 6, 8, 10],
            'hungarian_minor': [0, 2, 3, 6, 7, 8, 11],
            'persian': [0, 1, 4, 5, 6, 8, 11],
            'japanese': [0, 2, 5, 7, 8],
            'arabic': [0, 2, 4, 5, 6, 8, 10],
            'egyptian': [0, 2, 5, 7, 10],
            'chinese': [0, 4, 6, 7, 11],
            'altered': [0, 1, 3, 4, 6, 8, 10],
            'diminished': [0, 2, 3, 5, 6, 8, 9, 11],
            'whole_tone': [0, 2, 4, 6, 8, 10],
            'chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        };

        const NOTE_FREQUENCIES = {
            // First octave (C4-B4)
            'C': 261.63,   // C4
            'C#': 277.18,  // C#4
            'D': 293.66,   // D4
            'D#': 311.13,  // D#4
            'E': 329.63,   // E4
            'F': 349.23,   // F4
            'F#': 369.99,  // F#4
            'G': 392.00,   // G4
            'G#': 415.30,  // G#4
            'A': 440.00,   // A4
            'A#': 466.16,  // A#4
            'B': 493.88,   // B4
            
            // Second octave (C5-B5)
            'C2': 523.25,  // C5
            'C#2': 554.37, // C#5
            'D2': 587.33,  // D5
            'D#2': 622.25, // D#5
            'E2': 659.26,  // E5
            'F2': 698.46,  // F5
            'F#2': 739.99, // F#5
            'G2': 783.99,  // G5
            'G#2': 830.61, // G#5
            'A2': 880.00,  // A5
            'A#2': 932.33, // A#5
            'B2': 987.77   // B5
        };

        const CHORD_TYPES = {
            seventh: {
                I: [0, 4, 7, 11],    // maj7
                II: [0, 3, 7, 10],   // min7
                III: [0, 3, 7, 10],  // min7
                IV: [0, 4, 7, 11],   // maj7
                V: [0, 4, 7, 10],    // dom7
                VI: [0, 3, 7, 10],   // min7
                VII: [0, 3, 6, 10],  // min7b5
                bII: [0, 4, 7, 10],  // dom7
                bIII: [0, 4, 7, 10], // dom7
                bV: [0, 4, 7, 10],   // dom7
                bVI: [0, 4, 7, 10],  // dom7
                bVII: [0, 4, 7, 10]  // dom7
            },
            basic: {
                major: [0, 4, 7],
                minor: [0, 3, 7],
                diminished: [0, 3, 6],
                augmented: [0, 4, 8]
            },
            advanced: {
                major7: [0, 4, 7, 11],
                minor7: [0, 3, 7, 10],
                dom7: [0, 4, 7, 10],
                maj9: [0, 4, 7, 11, 14],
                min9: [0, 3, 7, 10, 14],
                dom9: [0, 4, 7, 10, 14],
                maj11: [0, 4, 7, 11, 14, 17],
                min11: [0, 3, 7, 10, 14, 17]
            }
        };

        const MOOD_PROGRESSIONS = {
            happy: {
                patterns: [
                    ['I', 'IV', 'V', 'I'],
                    ['I', 'VI', 'IV', 'V'],
                    ['I', 'IV', 'I', 'V']
                ]
            },
            sad: {
                patterns: [
                    ['I', 'VI', 'IV', 'V'],
                    ['VI', 'IV', 'I', 'V'],
                    ['I', 'III', 'VI', 'IV']
                ]
            },
            mysterious: {
                patterns: [
                    ['I', 'bII', 'IV', 'bVII'],
                    ['I', 'VI', 'III', 'VII'],
                    ['I', 'V', 'bVII', 'IV']
                ]
            },
            epic: {
                patterns: [
                    ['I', 'V', 'VI', 'IV'],
                    ['I', 'bVII', 'VI', 'V'],
                    ['I', 'III', 'VI', 'VII']
                ]
            },
            romantic: {
                patterns: [
                    ['I', 'VI', 'II', 'V'],
                    ['I', 'IV', 'II', 'V'],
                    ['I', 'III', 'IV', 'V']
                ]
            },
            melancholic: {
                patterns: [
                    ['I', 'bVI', 'bIII', 'bVII'],
                    ['I', 'bIII', 'IV', 'VI'],
                    ['VI', 'bIII', 'bVII', 'I']
                ]
            },
            dreamy: {
                patterns: [
                    ['I', 'bVII', 'IV', 'VI'],
                    ['I', 'III', 'bVI', 'IV'],
                    ['I', 'VI', 'bVII', 'V']
                ]
            },
            tense: {
                patterns: [
                    ['I', 'bII', 'bV', 'VII'],
                    ['I', 'VI', 'bII', 'V'],
                    ['I', 'bV', 'bII', 'VII']
                ]
            },
            peaceful: {
                patterns: [
                    ['I', 'IV', 'III', 'VI'],
                    ['I', 'III', 'VI', 'IV'],
                    ['I', 'VI', 'IV', 'III']
                ]
            }
        };

        function initUI() {
            const scaleSelect = document.getElementById('scale');
            const keySelect = document.getElementById('key');
            
            Object.keys(SCALES).forEach(scale => {
                const option = document.createElement('option');
                option.value = scale;
                option.textContent = scale.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                scaleSelect.appendChild(option);
            });
            
            NOTES.forEach(note => {
                const option = document.createElement('option');
                option.value = note;
                option.textContent = note;
                keySelect.appendChild(option);
            });
            
            createKeyboard();
            
            // Update when scale changes
            scaleSelect.addEventListener('change', () => {
                updateKeyboard();
                const progressionOutput = document.getElementById('progressionOutput');
                if (progressionOutput.textContent.trim() !== '') {
                    // Regenerate the progression with new scale
                    generateProgression();
                }
            });
            
            // Update when key changes
            keySelect.addEventListener('change', () => {
                updateKeyboard();
                const progressionOutput = document.getElementById('progressionOutput');
                if (progressionOutput.textContent.trim() !== '') {
                    updateExistingProgression(keySelect.value);
                }
            });
            
            updateKeyboard();
        }

        function initAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error('Web Audio API is not supported in this browser');
            }
        }

        function playNote(note) {
            if (!audioContext) {
                initAudioContext();
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            const baseFreq = NOTE_FREQUENCIES[note];
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.5);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1.6);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 1.6);

            // Visual feedback with proper color restoration
            const keyElement = document.querySelector(`[data-note="${note}"]`);
            if (keyElement) {
                const originalColor = keyElement.style.backgroundColor;
                keyElement.style.backgroundColor = 'var(--key-active)';
                keyElement.style.boxShadow = '0 0 10px var(--key-active)';
                
                setTimeout(() => {
                    // Get current scale and key for proper color restoration
                    const scale = document.getElementById('scale').value;
                    const key = document.getElementById('key').value;
                    const scaleNotes = getScaleNotes(key, SCALES[scale]);
                    const fifthNotes = getFifthNote(key);
                    const fourthNotes = getFourthNote(key);
                    
                    // Determine the correct color based on note's role
                    let restoredColor;
                    if (note === key || note === key + '2') {
                        restoredColor = 'var(--root-color)';
                    } else if (fifthNotes.includes(note)) {
                        restoredColor = 'var(--fifth-color)';
                    } else if (fourthNotes.includes(note)) {
                        restoredColor = 'var(--fourth-color)';
                    } else if (scaleNotes.includes(note)) {
                        restoredColor = 'var(--scale-color)';
                    } else {
                        restoredColor = keyElement.classList.contains('white') ? 'white' : '#333';
                    }
                    
                    keyElement.style.backgroundColor = restoredColor;
                    keyElement.style.boxShadow = 'none';
                }, 1000);
            }
        }

        function playChord(notes) {
            if (!audioContext) {
                initAudioContext();
            }

            // Sort notes for linear voicing
            const sortedNotes = arrangeNotesLinearly(notes);

            // Reset all key highlighting
            document.querySelectorAll('.key').forEach(key => {
                const scale = document.getElementById('scale').value;
                const baseKey = document.getElementById('key').value;
                const scaleNotes = getScaleNotes(baseKey, SCALES[scale]);
                const fifthNotes = getFifthNote(baseKey);
                const fourthNotes = getFourthNote(baseKey);
                
                const note = key.dataset.note;
                let color;
                if (note === baseKey || note === baseKey + '2') {
                    color = 'var(--root-color)';
                } else if (fifthNotes.includes(note)) {
                    color = 'var(--fifth-color)';
                } else if (fourthNotes.includes(note)) {
                    color = 'var(--fourth-color)';
                } else if (scaleNotes.includes(note)) {
                    color = 'var(--scale-color)';
                } else {
                    color = key.classList.contains('white') ? 'white' : '#333';
                }
                key.style.backgroundColor = color;
            });

            sortedNotes.forEach((note, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                const baseFreq = NOTE_FREQUENCIES[note];
                if (!baseFreq) {
                    console.warn(`Frequency not found for note: ${note}`);
                    return;
                }
                
                const baseVolume = 0.3;
                const volumeAdjust = index === 0 ? 1 : 0.8;
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                
                const startTime = audioContext.currentTime + (index * 0.02);
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(baseVolume * volumeAdjust, startTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 2.0);
                gainNode.gain.linearRampToValueAtTime(0, startTime + 2.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 2.2);

                // Highlight the corresponding key
                const keyElement = document.querySelector(`[data-note="${note}"]`);
                if (keyElement) {
                    keyElement.style.backgroundColor = 'var(--key-active)';
                    keyElement.style.boxShadow = '0 0 10px var(--key-active)';
                    
                    // Reset after the note duration with proper color
                    setTimeout(() => {
                        const scale = document.getElementById('scale').value;
                        const baseKey = document.getElementById('key').value;
                        const scaleNotes = getScaleNotes(baseKey, SCALES[scale]);
                        const fifthNotes = getFifthNote(baseKey);
                        const fourthNotes = getFourthNote(baseKey);
                        
                        let restoredColor;
                        if (note === baseKey || note === baseKey + '2') {
                            restoredColor = 'var(--root-color)';
                        } else if (fifthNotes.includes(note)) {
                            restoredColor = 'var(--fifth-color)';
                        } else if (fourthNotes.includes(note)) {
                            restoredColor = 'var(--scale-color)';
                        } else if (scaleNotes.includes(note)) {
                            restoredColor = 'var(--scale-color)';
                        } else {
                            restoredColor = keyElement.classList.contains('white') ? 'white' : '#333';
                        }
                        
                        keyElement.style.backgroundColor = restoredColor;
                        keyElement.style.boxShadow = 'none';
                    }, 2000);
                }
            });
        }

        function arrangeNotesLinearly(notes) {
            // First, normalize all notes to their base form (without octave)
            const baseNotes = notes.map(note => note.replace('2', ''));
            const uniqueBaseNotes = [...new Set(baseNotes)];
            
            // Get the root note (first note) and its index
            const rootNote = uniqueBaseNotes[0];
            const rootIndex = NOTES.indexOf(rootNote);
            
            // Sort remaining notes by their interval from the root
            const remainingNotes = uniqueBaseNotes.slice(1).sort((a, b) => {
                const aInterval = (NOTES.indexOf(a) - rootIndex + 12) % 12;
                const bInterval = (NOTES.indexOf(b) - rootIndex + 12) % 12;
                return aInterval - bInterval;
            });
            
            // Start with root note
            const voicedNotes = [rootNote];
            
            // Handle all additional notes with the same wrap-around logic
            remainingNotes.forEach(note => {
                const noteIndex = NOTES.indexOf(note);
                let shouldBeUpperOctave = false;
                
                // If this note's index is less than root, it wrapped around
                if (noteIndex < rootIndex) {
                    shouldBeUpperOctave = true;
                }
                // For notes after root, check if they're too far ahead
                else {
                    const interval = (noteIndex - rootIndex + 12) % 12;
                    // If adding this interval to root position would exceed octave
                    if (rootIndex + interval >= 12) {
                        shouldBeUpperOctave = true;
                    }
                }
                
                // Add the note with or without octave marking
                if (shouldBeUpperOctave && NOTE_FREQUENCIES[note + '2']) {
                    voicedNotes.push(note + '2');
                } else {
                    voicedNotes.push(note);
                }
            });
            
            return voicedNotes;
        }

        function playProgression() {
            const chordItems = document.querySelectorAll('.chord-item');
            if (!chordItems.length) return;
            
            let currentChordIndex = 0;
            const playButton = document.getElementById('playProgressionBtn');
            const tempo = document.getElementById('tempoSelect').value;
            const interval = 60000 / tempo; // Convert BPM to milliseconds
            
            const playNextChord = () => {
                if (!isPlaying) return;
                
                // Reset previous chord's visual state
                chordItems.forEach(item => item.classList.remove('playing'));
                
                const currentChord = chordItems[currentChordIndex];
                const chordNotes = currentChord.querySelector('.chord-notes')
                    .textContent.split(': ')[1].split(', ');
                
                // Play the chord and show visual feedback
                playChord(chordNotes);
                currentChord.classList.add('playing');
                
                // Update keyboard visual feedback
                document.querySelectorAll('.key').forEach(key => {
                    if (chordNotes.includes(key.dataset.note)) {
                        key.style.transform = 'translateY(2px)';
                        setTimeout(() => {
                            key.style.transform = 'translateY(0)';
                        }, 1000);
                    }
                });
                
                // Move to next chord
                currentChordIndex = (currentChordIndex + 1) % chordItems.length;
            };
            
            // Start/Stop the progression
            if (!isPlaying) {
                isPlaying = true;
                playButton.textContent = '⏹ Stop';
                playButton.classList.add('playing');
                playNextChord(); // Play first chord immediately
                progressionInterval = setInterval(playNextChord, interval);
            } else {
                isPlaying = false;
                playButton.textContent = '▶ Play';
                playButton.classList.remove('playing');
                clearInterval(progressionInterval);
                progressionInterval = null;
                // Reset all visual states
                chordItems.forEach(item => item.classList.remove('playing'));
                document.querySelectorAll('.key').forEach(key => {
                    key.style.transform = 'translateY(0)';
                });
            }
        }

        function createKeyboard() {
            const keyboard = document.getElementById('keyboard');
            const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const blackKeys = ['C#', 'D#', 'F#', 'G#', 'A#'];
            
            // Create two octaves
            for (let octave = 0; octave < 2; octave++) {
                // White keys
                whiteKeys.forEach((note, i) => {
                    const key = document.createElement('div');
                    key.className = 'key white';
                    key.dataset.note = octave === 0 ? note : note + '2';
                    key.style.left = `${(i + octave * 7) * 35 + 10}px`;
                    
                    // Store original color
                    key.dataset.originalColor = 'white';
                    
                    // Add touch and mouse event listeners
                    addKeyEventListeners(key);
                    
                    keyboard.appendChild(key);
                });
                
                // Black keys
                blackKeys.forEach((note, i) => {
                    const key = document.createElement('div');
                    key.className = 'key black';
                    key.dataset.note = octave === 0 ? note : note + '2';
                    const offset = [1, 2, 4, 5, 6][i];
                    key.style.left = `${(offset + octave * 7) * 35 - 10 + 10}px`;
                    
                    // Store original color
                    key.dataset.originalColor = '#333';
                    
                    // Add touch and mouse event listeners
                    addKeyEventListeners(key);
                    
                    keyboard.appendChild(key);
                });
            }
        }

        function updateKeyColor(key) {
            const scale = document.getElementById('scale').value;
            const baseKey = document.getElementById('key').value;
            const scaleNotes = getScaleNotes(baseKey, SCALES[scale]);
            const fifthNotes = getFifthNote(baseKey);
            const fourthNotes = getFourthNote(baseKey);
            
            const note = key.dataset.note;
            const isSecondOctave = note.endsWith('2');
            
            if (note === baseKey || note === baseKey + '2') {
                key.style.backgroundColor = 'var(--root-color)';
            } else if (fifthNotes.includes(note)) {
                key.style.backgroundColor = 'var(--fifth-color)';
            } else if (fourthNotes.includes(note)) {
                key.style.backgroundColor = 'var(--fourth-color)';
            } else if (scaleNotes.includes(note)) {
                key.style.backgroundColor = 'var(--scale-color)';
            } else {
                key.style.backgroundColor = key.classList.contains('white') ? 'white' : '#333';
            }
        }

        function addKeyEventListeners(key) {
            // Track if the key is currently being pressed
            let isPressed = false;
            
            // Function to handle key press
            const handleKeyPress = (e) => {
                if (!isPressed) {
                    isPressed = true;
                    playNote(key.dataset.note);
                    key.style.backgroundColor = 'var(--key-active)';
                    key.style.boxShadow = '0 0 10px var(--key-active)';
                    key.style.transform = 'translateY(2px)';
                }
                // Prevent default behavior to avoid unwanted effects
                e.preventDefault();
            };
            
            // Function to handle key release
            const handleKeyRelease = () => {
                if (isPressed) {
                    isPressed = false;
                    // Reset key appearance
                    updateKeyColor(key);
                    key.style.boxShadow = 'none';
                    key.style.transform = 'translateY(0)';
                }
            };
            
            // Mouse events
            key.addEventListener('mousedown', handleKeyPress);
            key.addEventListener('mouseup', handleKeyRelease);
            key.addEventListener('mouseleave', handleKeyRelease);
            
            // Touch events
            key.addEventListener('touchstart', handleKeyPress, { passive: false });
            key.addEventListener('touchend', handleKeyRelease);
            key.addEventListener('touchcancel', handleKeyRelease);
            
            // Prevent context menu on long press
            key.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function updateKeyboard() {
            const scale = document.getElementById('scale').value;
            const key = document.getElementById('key').value;
            const scaleNotes = getScaleNotes(key, SCALES[scale]);
            const fifthNotes = getFifthNote(key);
            const fourthNotes = getFourthNote(key);
            
            // Update complementary keys display
            const complementaryKeySpan = document.querySelector('#complementaryKeyInfo');
            const fourthKeySpan = document.querySelector('#fourthKeyInfo');
            
            if (complementaryKeySpan) {
                complementaryKeySpan.textContent = fifthNotes[0];
                complementaryKeySpan.style.color = 'var(--fifth-color)';
            }
            
            if (fourthKeySpan) {
                fourthKeySpan.textContent = fourthNotes[0];
                fourthKeySpan.style.color = 'var(--fourth-color)';
            }
            
            // Update keyboard visualization
            document.querySelectorAll('.key').forEach(keyElement => {
                const note = keyElement.dataset.note;
                if (note === key || note === key + '2') {
                    keyElement.style.backgroundColor = 'var(--root-color)';
                } else if (fifthNotes.includes(note)) {
                    keyElement.style.backgroundColor = 'var(--fifth-color)';
                } else if (fourthNotes.includes(note)) {
                    keyElement.style.backgroundColor = 'var(--fourth-color)';
                } else if (scaleNotes.includes(note)) {
                    keyElement.style.backgroundColor = 'var(--scale-color)';
                } else {
                    keyElement.style.backgroundColor = keyElement.classList.contains('white') ? 'white' : '#333';
                }
            });
            
            // Update existing progression if one exists
            const progressionOutput = document.getElementById('progressionOutput');
            if (progressionOutput.textContent.trim() !== '') {
                updateExistingProgression(key);
            }
        }

        function getScaleNotes(key, intervals) {
            const keyIndex = NOTES.indexOf(key);
            // Get first octave
            const firstOctave = intervals.map(interval => 
                NOTES[(keyIndex + interval) % 12]
            );
            // Get second octave
            const secondOctave = intervals.map(interval => 
                NOTES[(keyIndex + interval) % 12] + '2'
            );
            return [...firstOctave, ...secondOctave];
        }

        function getFifthNote(key) {
            const keyIndex = NOTES.indexOf(key);
            const firstOctave = NOTES[(keyIndex + 7) % 12];
            const secondOctave = NOTES[(keyIndex + 7) % 12] + '2';
            return [firstOctave, secondOctave];
        }

        function getFourthNote(key) {
            const keyIndex = NOTES.indexOf(key);
            const firstOctave = NOTES[(keyIndex + 5) % 12];
            const secondOctave = NOTES[(keyIndex + 5) % 12] + '2';
            return [firstOctave, secondOctave];
        }

        function getChordNotes(root, degree, type, modes, scale, key) {
            // Get notes for the current scale
            const scaleNotes = getScaleNotes(key, SCALES[scale]);
            const rootIndex = NOTES.indexOf(root);
            let intervals;

            if (modes.complex) {
                // In complex mode, use the appropriate intervals based on chord type
                if (modes.seventh) {
                    intervals = CHORD_TYPES.seventh[degree];
                } else if (modes.advanced) {
                    const advancedTypes = Object.keys(CHORD_TYPES.advanced);
                    const randomType = advancedTypes[Math.floor(Math.random() * advancedTypes.length)];
                    intervals = CHORD_TYPES.advanced[randomType];
                } else {
                    intervals = type.includes('m') ? CHORD_TYPES.basic.minor :
                            type.includes('dim') ? CHORD_TYPES.basic.diminished :
                            type.includes('aug') ? CHORD_TYPES.basic.augmented :
                            CHORD_TYPES.basic.major;
                }
                // Use intervals directly since we're allowing out-of-scale notes in complex mode
                return intervals.map(interval => NOTES[(rootIndex + interval) % 12]);
            } else {
                // When not in complex mode, strictly use scale notes
                let chordNotes = [root];
                let noteIndex = scaleNotes.indexOf(root);
                
                // Build chord using scale degrees
                for (let i = 1; i < scaleNotes.length; i++) {
                    const nextIndex = (noteIndex + 2) % scaleNotes.length;
                    chordNotes.push(scaleNotes[nextIndex]);
                    noteIndex = nextIndex;
                    
                    if (modes.seventh && chordNotes.length === 4) break;
                    if (!modes.seventh && chordNotes.length === 3) break;
                }
                
                return chordNotes;
            }
        }

        function getExtendedChordNotes(root, degree, type, modes, scale, key) {
            // Similar to getChordNotes but handles octave notation
            const baseNotes = getChordNotes(root, degree, type, modes, scale, key);
            
            return baseNotes.map((note, index) => {
                // Add octave notation for higher notes
                const useSecondOctave = (baseNotes.length === 4 && index === 3) || 
                                    (baseNotes.length > 4 && index >= 3);
                return note + (useSecondOctave ? '2' : '');
            });
        }

        function generateExtendedProgression(basePattern, chordCount, mood, scale) {
            if (chordCount <= basePattern.length) {
                return basePattern.slice(0, chordCount);
            }
            
            let progression = [...basePattern];
            const moodPatterns = MOOD_PROGRESSIONS[mood].patterns;
            
            // Adjust patterns based on scale characteristics
            const adjustPatternsForScale = (patterns) => {
                // For minor-type scales, adjust major patterns to minor equivalents
                if (['minor', 'harmonic_minor', 'melodic_minor', 'phrygian', 'locrian'].includes(scale)) {
                    return patterns.map(pattern => 
                        pattern.map(chord => {
                            // Convert major degrees to minor where appropriate
                            if (chord === 'I') return 'i';
                            if (chord === 'IV') return 'iv';
                            if (chord === 'V') return 'v';
                            return chord;
                        })
                    );
                }
                return patterns;
            };

            const adjustedPatterns = adjustPatternsForScale(moodPatterns);
            
            while (progression.length < chordCount) {
                let nextPattern;
                do {
                    nextPattern = adjustedPatterns[Math.floor(Math.random() * adjustedPatterns.length)];
                } while (nextPattern === basePattern && adjustedPatterns.length > 1);
                
                const variation = generateVariation(nextPattern, mood, scale);
                progression = progression.concat(variation);
            }
            
            return progression.slice(0, chordCount);
        }

        function generateVariation(pattern, mood, scale) {
            const substitutions = {
                // Major scale substitutions
                'I': ['I', 'III', 'VI'],
                'IV': ['IV', 'II', 'VI'],
                'V': ['V', 'VII', 'III'],
                'VI': ['VI', 'IV', 'II'],
                'II': ['II', 'IV', 'VII'],
                'III': ['III', 'VI', 'I'],
                'VII': ['VII', 'V', 'III'],
                // Minor scale substitutions
                'i': ['i', 'III', 'VI'],
                'iv': ['iv', 'II', 'VI'],
                'v': ['v', 'VII', 'III'],
                'vi': ['VI', 'iv', 'ii'],
                'ii': ['ii', 'iv', 'vii'],
                'iii': ['III', 'vi', 'i'],
                'vii': ['vii', 'v', 'iii']
            };

            const isMinorScale = ['minor', 'harmonic_minor', 'melodic_minor', 'phrygian', 'locrian'].includes(scale);
            
            return pattern.map(chord => {
                if (Math.random() < 0.3 && substitutions[chord]) {
                    const possibleSubs = substitutions[chord];
                    return possibleSubs[Math.floor(Math.random() * possibleSubs.length)];
                }
                return chord;
            });
        }

        function generateProgression() {
            // Clear any existing progression playback
            if (progressionInterval) {
                clearInterval(progressionInterval);
                progressionInterval = null;
                isPlaying = false;
            }
            
            const scale = document.getElementById('scale').value;
            const key = document.getElementById('key').value;
            const mood = document.getElementById('mood').value;
            const chordCount = parseInt(document.getElementById('chordCount').value);
            
            const modes = {
                seventh: document.getElementById('seventhMode').checked,
                advanced: document.getElementById('advancedMode').checked,
                complex: document.getElementById('complexMode').checked
            };
            
            const moodPatterns = MOOD_PROGRESSIONS[mood].patterns;
            const basePattern = moodPatterns[Math.floor(Math.random() * moodPatterns.length)];
            const progression = generateExtendedProgression(basePattern, chordCount, mood, scale);
            
            const scaleNotes = getScaleNotes(key, SCALES[scale]);
            const fifthKey = NOTES[(NOTES.indexOf(key) + 7) % 12];
            const fifthScaleNotes = getScaleNotes(fifthKey, SCALES[scale]);
            const fourthKey = NOTES[(NOTES.indexOf(key) + 5) % 12];
            const fourthScaleNotes = getScaleNotes(fourthKey, SCALES[scale]);
            
            const chords = [];
            const chordDetails = [];
            
            progression.forEach(degree => {
                const rootIndex = romanToNumber(degree);
                let chordRoot = scaleNotes[rootIndex % scaleNotes.length];
                let usesFifthOrFourth = false;
                let borrowedKey = key;
                
                // Complex mode logic for borrowing chords
                if (modes.complex && Math.random() < 0.4) {  // 40% chance to use borrowed chord
                    if (Math.random() < 0.5) {  // 50/50 chance between fifth and fourth
                        // Use a chord from the fifth key's scale
                        const fifthScaleIndex = Math.floor(Math.random() * fifthScaleNotes.length);
                        const borrowedNote = fifthScaleNotes[fifthScaleIndex];
                        if (!scaleNotes.includes(borrowedNote)) {
                            chordRoot = borrowedNote;
                            usesFifthOrFourth = true;
                            borrowedKey = fifthKey;
                        }
                    } else {
                        // Use a chord from the fourth key's scale
                        const fourthScaleIndex = Math.floor(Math.random() * fourthScaleNotes.length);
                        const borrowedNote = fourthScaleNotes[fourthScaleIndex];
                        if (!scaleNotes.includes(borrowedNote)) {
                            chordRoot = borrowedNote;
                            usesFifthOrFourth = true;
                            borrowedKey = fourthKey;
                        }
                    }
                }
                
                const chordType = getChordQuality(degree, scale);
                // If we're using a borrowed chord, we need to use notes from that chord's scale
                const notes = getExtendedChordNotes(
                    chordRoot, 
                    degree, 
                    chordType, 
                    modes, 
                    scale,
                    borrowedKey
                );
                
                let chordSymbol = chordRoot + chordType;
                if (modes.advanced || modes.seventh) {
                    chordSymbol += notes.length > 3 ? 
                        (notes.length === 4 ? '7' : 
                        notes.length === 5 ? '9' : 
                        '11') : '';
                }
                
                // Get proper chord name based on actual notes used
                const chordName = getChordNameFromNotes(notes, chordSymbol);
                
                chords.push(chordName);
                chordDetails.push({
                    symbol: chordName,
                    notes: notes,
                    degree: degree,
                    borrowed: usesFifthOrFourth ? (borrowedKey === fifthKey ? 'fifth' : 'fourth') : null
                });
            });
            
            updateProgressionDisplay(chords, chordDetails, key, fifthKey);
            
            // Reset any active play states
            const playButton = document.getElementById('playProgressionBtn');
            if (playButton) {
                playButton.textContent = '▶ Play';
                playButton.classList.remove('playing');
            }
            
            // Reset key highlighting
            document.querySelectorAll('.key').forEach(key => {
                updateKeyColor(key);
            });
            
            // Remove any active chord highlighting
            document.querySelectorAll('.chord-item').forEach(item => {
                item.classList.remove('playing');
            });
        }

        function updateProgressionDisplay(chords, chordDetails, key, fifthKey) {
            const outputEl = document.getElementById('progressionOutput');
            outputEl.innerHTML = '';

            const keysDiv = document.createElement('div');
            keysDiv.className = 'progression-keys';
            keysDiv.innerHTML = `
                <div class="progression-info">
                    <span class="progression-label">Base Key:</span>
                    <span class="progression-value">${key}</span>
                    <span class="progression-separator">|</span>
                    <span class="progression-label">Complementary Key:</span>
                    <span class="progression-value">${fifthKey}</span>
                </div>
                <div class="progression-sequence">
                    <span class="progression-label">Progression</span>
                    <div class="progression-chain">${chords.join('<span class="progression-arrow">→</span>')}</div>
                </div>
            `;
            outputEl.appendChild(keysDiv);

            const chordListDiv = document.createElement('div');
            chordListDiv.className = 'chord-list';

            chordDetails.forEach((chord, i) => {
                const chordDiv = document.createElement('div');
                chordDiv.className = 'chord-item';

                // Get proper chord name based on notes
                const chordName = getChordNameFromNotes(chord.notes, chord.symbol);

                const chordSymbol = document.createElement('div');
                chordSymbol.className = 'chord-symbol';
                chordSymbol.textContent = `Chord ${i + 1} (${chord.degree}): ${chordName}`;

                const chordNotes = document.createElement('div');
                chordNotes.className = 'chord-notes';
                chordNotes.textContent = `Notes: ${chord.notes.join(', ')}`;

                const playButton = document.createElement('button');
                playButton.className = 'play-chord-button';
                playButton.textContent = '▶ Play';
                
                const playChordHandler = () => {
                    playChord(chord.notes);
                    chordDiv.classList.add('playing');
                    setTimeout(() => {
                        chordDiv.classList.remove('playing');
                    }, 1000);
                    
                    document.querySelectorAll('.key').forEach(key => {
                        if (chord.notes.includes(key.dataset.note)) {
                            key.style.transform = 'translateY(2px)';
                            setTimeout(() => {
                                key.style.transform = 'translateY(0)';
                            }, 1000);
                        }
                    });
                };
                
                chordDiv.addEventListener('click', playChordHandler);
                playButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    playChordHandler();
                });
                
                chordDiv.appendChild(chordSymbol);
                chordDiv.appendChild(chordNotes);
                chordDiv.appendChild(playButton);
                chordListDiv.appendChild(chordDiv);
            });
            
            outputEl.appendChild(chordListDiv);
            const playControlsContainer = document.createElement('div');
            playControlsContainer.className = 'play-controls-container';
            
            const tempoContainer = document.createElement('div');
            tempoContainer.className = 'tempo-container';
            
            const tempoSelect = document.createElement('select');
            tempoSelect.id = 'tempoSelect';
            [
                { value: 30, label: 'Slow' },
                { value: 45, label: 'Medium' },
                { value: 60, label: 'Fast' }
            ].forEach(tempo => {
                const option = document.createElement('option');
                option.value = tempo.value;
                option.textContent = tempo.label;
                if (tempo.value === 45) option.selected = true;
                tempoSelect.appendChild(option);
            });
            
            const tempoLabel = document.createElement('label');
            tempoLabel.htmlFor = 'tempoSelect';
            tempoLabel.textContent = 'Tempo: ';
            
            tempoContainer.appendChild(tempoLabel);
            tempoContainer.appendChild(tempoSelect);
            
            const playButton = document.createElement('button');
            playButton.id = 'playProgressionBtn';
            playButton.textContent = '▶ Play';
            playButton.onclick = playProgression;
            
            playControlsContainer.appendChild(tempoContainer);
            playControlsContainer.appendChild(playButton);
            
            outputEl.appendChild(playControlsContainer);
        }

        function getChordNameFromNotes(notes, defaultSymbol) {
            // Remove octave numbers for analysis
            const baseNotes = notes.map(note => note.replace('2', ''));
            const root = baseNotes[0];
            
            // Calculate intervals from root
            const intervals = baseNotes.slice(1).map(note => {
                const rootIndex = NOTES.indexOf(root);
                const noteIndex = NOTES.indexOf(note);
                return (noteIndex - rootIndex + 12) % 12;
            });

            // Common chord interval patterns
            const chordPatterns = {
                // Major triad
                '4,7': '',
                // Minor triad
                '3,7': 'm',
                // Diminished triad
                '3,6': 'dim',
                // Augmented triad
                '4,8': 'aug',
                // Major seventh
                '4,7,11': 'maj7',
                // Minor seventh
                '3,7,10': 'm7',
                // Dominant seventh
                '4,7,10': '7',
                // Half diminished seventh
                '3,6,10': 'm7b5',
                // Diminished seventh
                '3,6,9': 'dim7',
                // Major ninth
                '4,7,11,14': 'maj9',
                // Minor ninth
                '3,7,10,14': 'm9',
                // Dominant ninth
                '4,7,10,14': '9',
                // Major eleventh
                '4,7,11,14,17': 'maj11',
                // Minor eleventh
                '3,7,10,14,17': 'm11'
            };

            const intervalKey = intervals.join(',');
            const quality = chordPatterns[intervalKey];

            if (quality !== undefined) {
                return root + quality;
            }

            // If no match found, return the default symbol
            return defaultSymbol;
        }

        function updateExistingProgression(newKey) {
            const outputEl = document.getElementById('progressionOutput');
            if (!outputEl.textContent) return;
            
            const chordItems = document.querySelectorAll('.chord-item');
            if (!chordItems.length) return;
            
            const scale = document.getElementById('scale').value;
            const fifthKey = NOTES[(NOTES.indexOf(newKey) + 7) % 12];
            const modes = {
                seventh: document.getElementById('seventhMode').checked,
                advanced: document.getElementById('advancedMode').checked,
                complex: document.getElementById('complexMode').checked
            };
            
            // Update the keys display section
            const keysDiv = outputEl.querySelector('.progression-keys');
            if (keysDiv) {
                const keyInfoHTML = `
                    <div class="progression-info">
                        <span class="progression-label">Base Key:</span>
                        <span class="progression-value">${newKey}</span>
                        <span class="progression-separator">|</span>
                        <span class="progression-label">Complementary Key:</span>
                        <span class="progression-value">${fifthKey}</span>
                    </div>
                `;
                keysDiv.innerHTML = keyInfoHTML;
            }
            
            const newChords = [];
            chordItems.forEach((item) => {
                const chordSymbolEl = item.querySelector('.chord-symbol');
                const chordText = chordSymbolEl.textContent;
                const degreeMatch = chordText.match(/\((.*?)\)/);
                
                if (degreeMatch) {
                    const degree = degreeMatch[1];
                    const rootIndex = romanToNumber(degree);
                    const scaleNotes = getScaleNotes(newKey, SCALES[scale]);
                    let chordRoot = scaleNotes[rootIndex % scaleNotes.length];
                    
                    // Get the chord quality based on both degree and scale
                    const chordType = getChordQuality(degree, scale);
                    const notes = getExtendedChordNotes(chordRoot, degree, chordType, modes);
                    
                    let chordSymbol = chordRoot + chordType;
                    if (modes.advanced || modes.seventh) {
                        chordSymbol += notes.length > 3 ? 
                            (notes.length === 4 ? '7' : 
                            notes.length === 5 ? '9' : 
                            '11') : '';
                    }
                    
                    newChords.push(chordSymbol);
                    
                    // Update the display for this chord
                    const chordNumber = Array.from(chordItems).indexOf(item) + 1;
                    chordSymbolEl.textContent = `Chord ${chordNumber} (${degree}): ${chordSymbol}`;
                    
                    const chordNotesEl = item.querySelector('.chord-notes');
                    if (chordNotesEl) {
                        chordNotesEl.textContent = `Notes: ${notes.join(', ')}`;
                    }
                }
            });
            
            // Update the progression sequence display
            const sequenceDiv = outputEl.querySelector('.progression-chain');
            if (sequenceDiv) {
                sequenceDiv.innerHTML = newChords.join('<span class="progression-arrow">→</span>');
            }
        }

        function romanToNumber(roman) {
            const numerals = {
                'I': 0, 'II': 1, 'III': 2, 'IV': 3, 'V': 4, 'VI': 5, 'VII': 6,
                'bII': 1, 'bIII': 2, 'bIV': 3, 'bV': 4, 'bVI': 5, 'bVII': 6
            };
            return numerals[roman] || 0;
        }

        function getChordQuality(degree, scale) {
            // Define chord qualities for different scales
            const scaleQualities = {
                'major': {
                    'I': '', 'II': 'm', 'III': 'm', 'IV': '', 'V': '', 'VI': 'm', 'VII': 'dim',
                    'bII': 'm', 'bIII': 'm', 'bV': 'm', 'bVI': 'm', 'bVII': 'm'
                },
                'minor': {
                    'I': 'm', 'II': 'dim', 'III': '', 'IV': 'm', 'V': 'm', 'VI': '', 'VII': '',
                    'bII': 'm', 'bIII': '', 'bV': 'm', 'bVI': '', 'bVII': ''
                },
                'harmonic_minor': {
                    'I': 'm', 'II': 'dim', 'III': '', 'IV': 'm', 'V': '', 'VI': '', 'VII': 'dim',
                    'bII': 'm', 'bIII': '', 'bV': '', 'bVI': '', 'bVII': ''
                },
                'melodic_minor': {
                    'I': 'm', 'II': 'm', 'III': '', 'IV': '', 'V': '', 'VI': 'dim', 'VII': 'dim',
                    'bII': 'm', 'bIII': '', 'bV': '', 'bVI': 'dim', 'bVII': 'dim'
                },
                'dorian': {
                    'I': 'm', 'II': 'm', 'III': '', 'IV': '', 'V': 'm', 'VI': 'dim', 'VII': '',
                    'bII': 'm', 'bIII': '', 'bV': 'm', 'bVI': 'dim', 'bVII': ''
                },
                'phrygian': {
                    'I': 'm', 'II': '', 'III': '', 'IV': 'm', 'V': 'dim', 'VI': '', 'VII': 'm',
                    'bII': '', 'bIII': '', 'bV': 'dim', 'bVI': '', 'bVII': 'm'
                },
                'lydian': {
                    'I': '', 'II': '', 'III': 'm', 'IV': 'dim', 'V': '', 'VI': 'm', 'VII': 'm',
                    'bII': '', 'bIII': 'm', 'bV': '', 'bVI': 'm', 'bVII': 'm'
                },
                'mixolydian': {
                    'I': '', 'II': 'm', 'III': 'dim', 'IV': '', 'V': 'm', 'VI': 'm', 'VII': '',
                    'bII': 'm', 'bIII': 'dim', 'bV': 'm', 'bVI': 'm', 'bVII': ''
                },
                'locrian': {
                    'I': 'dim', 'II': '', 'III': 'm', 'IV': 'm', 'V': '', 'VI': '', 'VII': 'm',
                    'bII': '', 'bIII': 'm', 'bV': '', 'bVI': '', 'bVII': 'm'
                }
            };

            // Default to major scale qualities if scale not found
            const scaleType = scale.toLowerCase();
            const qualities = scaleQualities[scaleType] || scaleQualities.major;
            
            return qualities[degree] || '';
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            initUI();
            
            // Prevent double-tap zoom on iOS
            document.addEventListener('touchend', (e) => {
                if (e.target.classList.contains('key')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Add keyboard controls
            document.addEventListener('keydown', (event) => {
                // Prevent repeated triggers while holding key
                if (event.repeat) return;
                
                // Map keyboard keys to notes
                const keyMap = {
                    'a': 'C',
                    'w': 'C#',
                    's': 'D',
                    'e': 'D#',
                    'd': 'E',
                    'f': 'F',
                    't': 'F#',
                    'g': 'G',
                    'y': 'G#',
                    'h': 'A',
                    'u': 'A#',
                    'j': 'B',
                    // Second octave
                    'k': 'C2',
                    'o': 'C#2',
                    'l': 'D2',
                    'p': 'D#2',
                    ';': 'E2',
                    "'": 'F2'
                };
                
                const note = keyMap[event.key.toLowerCase()];
                if (note) {
                    playNote(note);
                    // Add visual feedback to the corresponding key
                    const keys = document.querySelectorAll('.key');
                    keys.forEach(key => {
                        if (key.dataset.note === note) {
                            key.style.transform = 'translateY(2px)';
                            setTimeout(() => {
                                key.style.transform = 'translateY(0)';
                            }, 150);
                        }
                    });
                }
            });

            // Add keyup handler to reset visual state
            document.addEventListener('keyup', (event) => {
                const keyMap = {
                    'a': 'C',
                    'w': 'C#',
                    's': 'D',
                    'e': 'D#',
                    'd': 'E',
                    'f': 'F',
                    't': 'F#',
                    'g': 'G',
                    'y': 'G#',
                    'h': 'A',
                    'u': 'A#',
                    'j': 'B',
                    'k': 'C2',
                    'o': 'C#2',
                    'l': 'D2',
                    'p': 'D#2',
                    ';': 'E2',
                    "'": 'F2'
                };

                const note = keyMap[event.key.toLowerCase()];
                if (note) {
                    const keys = document.querySelectorAll('.key');
                    keys.forEach(key => {
                        if (key.dataset.note === note) {
                            key.style.transform = 'translateY(0)';
                        }
                    });
                }
            });
        });
    </script>
</body>
</html>
