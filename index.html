<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mabel's Theory</title>
    <meta name="theme-color" content="#121212">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Mabel's Theory">
    <style>
        :root {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --scale-color: #00ff9d;
            --root-color: #ff006e;
            --fifth-color: #8a2be2;
            --fourth-color: #FF8C00;
            --border-color: #333333;
            --hover-color: #2a2a2a;
            --key-active: #00f2ff;
            --transition-speed: 0.3s;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            max-width: 100%;
            overflow-x: hidden;
            padding: 10px;
        }

        .container {
            display: grid;
            gap: 12px;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Header and App Brand */
        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
        }

        .app-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0;
        }

        .app-subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Collapsible Sections */
        .collapsible-section {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
            margin-bottom: 12px;
            overflow: hidden;
        }

        .section-header {
            padding: 12px 15px;
            background: var(--bg-secondary);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background-color var(--transition-speed);
        }

        .section-header:hover {
            background-color: var(--hover-color);
        }

        .section-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .section-header .toggle-icon {
            transition: transform var(--transition-speed);
        }

        .section-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .section-content {
            padding: 15px;
            transition: max-height var(--transition-speed) ease;
            max-height: 800px;
            overflow: hidden;
        }

        .section-header.collapsed + .section-content {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        /* Key Info Styling */
        .key-info {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        @media (min-width: 768px) {
            .key-info {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .info-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        @media (min-width: 480px) {
            .info-item {
                flex-direction: row;
                align-items: center;
            }
        }

        .info-label {
            font-weight: bold;
            color: var(--scale-color);
            min-width: 90px;
        }

        select, input[type="number"] {
            flex: 1;
            min-height: 44px;
            padding: 8px 12px;
            font-size: 16px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            width: 100%;
        }

        @media (min-width: 480px) {
            select, input[type="number"] {
                width: auto;
            }
        }

        /* Legend as Tooltip */
        .legend-tooltip {
            position: relative;
            display: inline-block;
            margin-left: 10px;
        }

        .legend-tooltip-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .legend-tooltip-content {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            z-index: 10;
            width: max-content;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-speed);
        }

        .legend-tooltip:hover .legend-tooltip-content,
        .legend-tooltip:focus-within .legend-tooltip-content {
            opacity: 1;
            pointer-events: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }

        /* Install Button */
        .install-container {
            margin-left: 10px;
        }

        .install-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            padding: 0;
            min-height: auto;
        }

        .install-btn:hover {
            background: var(--hover-color);
        }

        /* Hide install button by default - will show when installation is available */
        #installBtn {
            display: none;
        }

        .color-box {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        /* Responsive Keyboard */
        .keyboard-container {
            width: 100%;
            padding: 5px 0;
            overflow: hidden;
            position: relative;
        }

        .keyboard-wrapper {
            overflow-x: auto;
            width: 100%;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 10px;
            display: flex;
            justify-content: center; /* This is good */
        }

        .keyboard {
            position: relative;
            height: 100px;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 10px;
            user-select: none;
            width: 100%; /* Fill the available width */
            max-width: 800px;
            min-width: auto; /* Remove fixed minimum width */
            border: 1px solid var(--border-color);
            margin: 0 auto; /* This is good */
            touch-action: manipulation;
        }

        .keyboard::after {
            content: '';
            display: block;
            clear: both;
        }

        .keyboard-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-weight: bold;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .key {
            position: absolute;
            border: 1px solid var(--border-color);
            border-radius: 0 0 4px 4px;
            cursor: pointer;
            transition: transform 0.15s ease, background-color 0.3s ease, box-shadow 0.3s ease;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .white {
            width: 35px;
            height: 100px;
            background: #ffffff;
        }

        .black {
            width: 20px;
            height: 65px;
            background: #000000;
            z-index: 1;
        }

        .key:hover {
            opacity: 0.9;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.1);
        }

        .key:active {
            transform: translateY(2px);
        }

        @media (max-width: 480px) {
            .keyboard {
                height: 80px;
            }
            
            .white {
                height: 80px;
                width: 28px;
            }
            
            .black {
                height: 50px;
                width: 16px;
            }
        }

        /* Controls Styling */
        .controls {
            display: grid;
            gap: 15px;
        }

        /* Tabs for Mobile */
        .mobile-tabs {
            display: none;
        }

        @media (max-width: 768px) {
            .mobile-tabs {
                display: flex;
                margin-bottom: 10px;
            }
            
            .tab-button {
                flex: 1;
                padding: 10px;
                background: var(--bg-secondary);
                border: 1px solid var(--border-color);
                color: var(--text-primary);
                cursor: pointer;
                text-align: center;
            }
            
            .tab-button.active {
                background: var(--hover-color);
                border-bottom-color: var(--scale-color);
            }
            
            .tab-content {
                display: none;
            }
            
            .tab-content.active {
                display: block;
            }
        }

        .control-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        @media (min-width: 768px) {
            .control-group {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }

        .mode-toggles {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        @media (min-width: 768px) {
            .mode-toggles {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        .chord-count-control, .toggle-switch {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            min-height: 44px;
        }

        .chord-count-control input {
            width: 70px;
            text-align: center;
        }

        .toggle-switch input[type="checkbox"] {
            width: 24px;
            height: 24px;
            margin: 0;
        }

        /* Custom Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-secondary);
            transition: .4s;
            border-radius: 24px;
            border: 1px solid var(--border-color);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 2px;
            background-color: var(--text-primary);
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--scale-color);
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }

        button {
            min-height: 44px;
            padding: 10px 20px;
            font-size: 16px;
            background: var(--root-color);
            color: var(--text-primary);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(1px);
        }

        .generate-button-container {
            display: flex;
            justify-content: center;
            margin-top: 15px;
        }

        /* Progression Output Styling */
        .progression-header {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--scale-color);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .progression-output {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .chord-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        @media (min-width: 768px) {
            .chord-list {
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 12px;
            }
        }

        .chord-item {
            padding: 12px;
            border-radius: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            position: relative;
            min-height: 44px;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .chord-item:hover {
            background-color: var(--hover-color);
        }

        .chord-item.playing {
            background-color: var(--hover-color);
            border-color: var(--scale-color);
            box-shadow: 0 0 8px var(--scale-color);
        }

        .play-chord-button {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            min-width: 44px;
            min-height: 44px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .play-controls-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px auto;
            text-align: center;
            max-width: 300px;
        }

        .tempo-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #tempoSelect {
            min-width: 100px;
            text-align: center;
        }

        #playProgressionBtn {
            background-color: var(--scale-color);
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        #playProgressionBtn.playing {
            background-color: var(--root-color);
        }

        /* Visual Metronome */
        .metronome {
            display: inline-block;
            width: 12px;
            height: 12px;
            background-color: var(--text-primary);
            border-radius: 50%;
            margin-left: 8px;
            opacity: 0.2;
            transition: opacity 0.1s ease;
        }

        .metronome.active {
            opacity: 1;
        }

        /* History Button */
        .history-button {
            background-color: var(--bg-secondary);
            margin-left: 10px;
            min-width: 36px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            padding: 0;
        }

        /* History Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid var(--border-color);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .close-modal {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            min-height: auto;
            line-height: 1;
        }

        .history-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: var(--bg-primary);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            border: 1px solid var(--border-color);
        }

        .history-item:hover {
            background-color: var(--hover-color);
        }

        /* Tooltip for keyboard shortcuts */
        .shortcuts-tooltip {
            position: absolute;
            top: -40px;
            right: 10px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: var(--text-secondary);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .keyboard-container:hover .shortcuts-tooltip {
            opacity: 1;
        }

        /* Sound Control */
        .sound-control {
            margin-top: 10px;
        }

        .sound-select {
            width: 100%;
            margin-top: 5px;
        }

        /* Advanced Options */
        .advanced-options {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }
    </style>
<!-- Web app manifest inline -->
<script type="application/json" id="pwaManifest">
    {
        "name": "Mabel's Theory",
        "short_name": "Mabel's Theory",
        "description": "Music Theory & Chord Progression Tool",
        "start_url": "./index.html",
        "display": "standalone",
        "background_color": "#121212",
        "theme_color": "#121212",
        "icons": [
            {
                "src": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZpbGw9Im5vbmUiPjxyZWN0IHdpZHRoPSIxMDI0IiBoZWlnaHQ9IjEwMjQiIGZpbGw9IiMxMjEyMTIiIHJ4PSIyMDAiLz48cGF0aCBkPSJNNzUwIDMwMEwyNzQgMzAwTDI3NCA3MjRMNzUwIDcyNEw3NTAgMzAwWiIgZmlsbD0iIzFlMWUxZSIgc3Ryb2tlPSIjMDBmZjlkIiBzdHJva2Utd2lkdGg9IjE2Ii8+PHBhdGggZD0iTTM1MCA0MDBMNDAwIDMwMEw0NTAgNDAwTDUwMCAzMDBMNTUwIDQwMEw2MDAgMzAwTDY1MCA0MDBMNjUwIDcwMEwzNTAgNzAwTDM1MCA0MDBaIiBmaWxsPSIjZmYwMDZlIi8+PHBhdGggZD0iTTQwMCA1MDBMNjAwIDUwMEw2MDAgNjAwTDQwMCA2MDBMNDAwIDUwMFoiIGZpbGw9IiM4YTJiZTIiLz48L3N2Zz4=",
                "sizes": "1024x1024",
                "type": "image/svg+xml",
                "purpose": "any maskable"
            }
        ]
    }
    </script>
    
    <!-- Apply the manifest programmatically -->
    <script>
        // Create a link element for the manifest
        const manifestData = document.getElementById('pwaManifest').textContent;
        const blob = new Blob([manifestData], {type: 'application/json'});
        const manifestURL = URL.createObjectURL(blob);
        
        const manifestLink = document.createElement('link');
        manifestLink.rel = 'manifest';
        manifestLink.href = manifestURL;
        document.head.appendChild(manifestLink);
    </script>
</head>
<body>
    <div class="container">
        <!-- App Header -->
        <header class="app-header">
            <div>
                <h1 class="app-title">Mabel's Theory</h1>
                <p class="app-subtitle">Music Theory & Chord Progression Tool</p>
            </div>
            <div class="legend-tooltip">
                <button class="legend-tooltip-btn" aria-label="Show legend">?</button>
                <div class="legend-tooltip-content" role="tooltip">
                    <div class="legend-item">
                        <div class="color-box" style="background: var(--root-color)"></div>
                        <span>Root Note</span>
                    </div>
                    <div class="legend-item">
                        <div class="color-box" style="background: var(--scale-color)"></div>
                        <span>Scale Notes</span>
                    </div>
                    <div class="legend-item">
                        <div class="color-box" style="background: var(--fifth-color)"></div>
                        <span>Circle of 5ths</span>
                    </div>
                    <div class="legend-item">
                        <div class="color-box" style="background: var(--fourth-color)"></div>
                        <span>Circle of 4ths</span>
                    </div>
                </div>
            </div>
            <div class="install-container">
                <button id="installBtn" class="install-btn" aria-label="Install app">+</button>
            </div>
        </header>

        <!-- Mobile Tabs (Only visible on small screens) -->
        <div class="mobile-tabs">
            <button class="tab-button active" data-tab="keyboard">Keyboard</button>
            <button class="tab-button" data-tab="settings">Settings</button>
            <button class="tab-button" data-tab="progression">Progression</button>
        </div>

        <!-- Keyboard Section -->
        <div class="tab-content active" id="keyboard-tab">
            <div class="collapsible-section">
                <div class="section-header">
                    <h3>Keyboard</h3>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="section-content">
                    <div class="keyboard-container">
                        <div class="shortcuts-tooltip">
                            Press A-L keys to play notes (A=C, W=C#, etc.)
                        </div>
                        <div class="keyboard-wrapper">
                            <div class="keyboard" id="keyboard"></div>
                        </div>
                        <div class="keyboard-controls">
                            <button class="zoom-btn" id="zoomOutBtn">-</button>
                            <button class="zoom-btn" id="zoomInBtn">+</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Section -->
        <div class="tab-content" id="settings-tab">
            <div class="collapsible-section">
                <div class="section-header">
                    <h3>Scale & Key Settings</h3>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="section-content">
                    <div class="key-info">
                        <div class="info-group">
                            <div class="info-item">
                                <span class="info-label">Scale:</span>
                                <select id="scale"></select>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Base Key:</span>
                                <select id="key"></select>
                            </div>
                        </div>
                        
                        <div class="info-group">
                            <div class="info-item">
                                <span class="info-label">Up 5th Key:</span>
                                <span id="complementaryKeyInfo"></span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Down 4th Key:</span>
                                <span id="fourthKeyInfo"></span>
                            </div>
                        </div>
                        
                        <div class="info-group">
                            <div class="info-item">
                                <span class="info-label">Sound:</span>
                                <select id="soundType" class="sound-select">
                                    <option value="sine">Sine Wave</option>
                                    <option value="piano">Piano</option>
                                    <option value="organ">Organ</option>
                                </select>
                            </div>
                            <div class="advanced-options">
                                <div class="toggle-switch">
                                    <label class="switch">
                                        <input type="checkbox" id="advancedAudioMode">
                                        <span class="slider"></span>
                                    </label>
                                    <span>Enhanced Audio</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Progression Section -->
        <div class="tab-content" id="progression-tab">
            <div class="collapsible-section">
                <div class="section-header">
                    <h3>Chord Progression Generator</h3>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="section-content">
                    <div class="info-item">
                        <span class="info-label">Progression:</span>
                        <select id="progressionType">
                            <option value="basic">Basic (I-IV-V)</option>
                            <option value="common">Common (I-VI-IV-V)</option>
                            <option value="extended">Extended (I-III-VI-IV)</option>
                            <option value="circle">Circle of 5ths (VI-II-V-I)</option>
                            <option value="jazz">Jazz (II-V-I)</option>
                            <option value="jazz2">Jazz II (III-VI-II-V)</option>
                            <option value="random">Random</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                    
                    <div id="customProgressionInput" style="display: none; margin-top: 10px;">
                        <div class="info-item">
                            <span class="info-label">Custom:</span>
                            <input type="text" id="customProgression" placeholder="e.g. I-IV-V-I" style="flex: 1;">
                        </div>
                    </div>
                    
                    <div class="mode-toggles">
                        <div class="chord-count-control">
                            <label for="chordCount">Chords:</label>
                            <input type="number" id="chordCount" min="2" max="16" value="4">
                        </div>
                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="seventhMode">
                                <span class="slider"></span>
                            </label>
                            <span>+7th Chords</span>
                        </div>
                        <div class="toggle-switch">
                            <label class="switch">
                                <input type="checkbox" id="advancedMode">
                                <span class="slider"></span>
                            </label>
                            <span>+9th/11th</span>
                        </div>
                    </div>
                    
                    <div class="generate-button-container">
                        <button id="generateBtn" onclick="generateProgression()">Generate Progression</button>
                        <button class="history-button" id="historyBtn" title="Progression History">
                            <span>⏱</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="progression-output">
                <div class="progression-header">
                    Chord Progression
                </div>
                <div id="progressionOutput"></div>
            </div>
        </div>

        <!-- History Modal -->
        <div class="modal" id="historyModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Progression History</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div id="historyList">
                    <!-- History items will be added here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let audioContext = null;
        let isPlaying = false;
        let progressionInterval = null;
        let keyboardZoom = 1;
        let progressionHistory = [];
        let enhancedAudio = false;
        let currentSoundType = 'sine';

        const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        const SCALES = {
            'major': [0, 2, 4, 5, 7, 9, 11],
            'minor': [0, 2, 3, 5, 7, 8, 10],
            'harmonic_minor': [0, 2, 3, 5, 7, 8, 11],
            'melodic_minor': [0, 2, 3, 5, 7, 9, 11],
            'dorian': [0, 2, 3, 5, 7, 9, 10],
            'phrygian': [0, 1, 3, 5, 7, 8, 10],
            'lydian': [0, 2, 4, 6, 7, 9, 11],
            'mixolydian': [0, 2, 4, 5, 7, 9, 10],
            'locrian': [0, 1, 3, 5, 6, 8, 10],
            'whole_tone': [0, 2, 4, 6, 8, 10],
            'diminished': [0, 2, 3, 5, 6, 8, 9, 11],
            'pentatonic_major': [0, 2, 4, 7, 9],
            'pentatonic_minor': [0, 3, 5, 7, 10],
            'blues': [0, 3, 5, 6, 7, 10]
        };

        const NOTE_FREQUENCIES = {
            // First octave (C4-B4)
            'C': 261.63,   // C4
            'C#': 277.18,  // C#4
            'D': 293.66,   // D4
            'D#': 311.13,  // D#4
            'E': 329.63,   // E4
            'F': 349.23,   // F4
            'F#': 369.99,  // F#4
            'G': 392.00,   // G4
            'G#': 415.30,  // G#4
            'A': 440.00,   // A4
            'A#': 466.16,  // A#4
            'B': 493.88,   // B4
            
            // Second octave (C5-B5)
            'C2': 523.25,  // C5
            'C#2': 554.37, // C#5
            'D2': 587.33,  // D5
            'D#2': 622.25, // D#5
            'E2': 659.26,  // E5
            'F2': 698.46,  // F5
            'F#2': 739.99, // F#5
            'G2': 783.99,  // G5
            'G#2': 830.61, // G#5
            'A2': 880.00,  // A5
            'A#2': 932.33, // A#5
            'B2': 987.77   // B5
        };

        // Defined chord types
        const CHORD_TYPES = {
            // Basic chord structures
            triad: {
                major: [0, 4, 7],
                minor: [0, 3, 7],
                diminished: [0, 3, 6],
                augmented: [0, 4, 8]
            },
            seventh: {
                major7: [0, 4, 7, 11],
                minor7: [0, 3, 7, 10],
                dom7: [0, 4, 7, 10],
                halfDim7: [0, 3, 6, 10],
                dim7: [0, 3, 6, 9]
            },
            extended: {
                maj9: [0, 4, 7, 11, 14],
                min9: [0, 3, 7, 10, 14],
                dom9: [0, 4, 7, 10, 14],
                maj11: [0, 4, 7, 11, 14, 17],
                min11: [0, 3, 7, 10, 14, 17]
            }
        };

        // Standard chord progressions by type
        const PROGRESSION_TYPES = {
            basic: ['I', 'IV', 'V'],
            common: ['I', 'VI', 'IV', 'V'],
            extended: ['I', 'III', 'VI', 'IV'],
            circle: ['VI', 'II', 'V', 'I'],
            jazz: ['II', 'V', 'I'],
            jazz2: ['III', 'VI', 'II', 'V'],
            random: null // Will be handled differently
        };

        // Chord qualities by scale degree for different scales
        const SCALE_CHORD_QUALITIES = {
            major: {
                'I': 'major',
                'II': 'minor',
                'III': 'minor',
                'IV': 'major',
                'V': 'major',
                'VI': 'minor',
                'VII': 'diminished'
            },
            minor: {
                'I': 'minor',
                'II': 'diminished',
                'III': 'major',
                'IV': 'minor',
                'V': 'minor',
                'VI': 'major',
                'VII': 'major'
            },
            harmonic_minor: {
                'I': 'minor',
                'II': 'diminished',
                'III': 'augmented',
                'IV': 'minor',
                'V': 'major',
                'VI': 'major',
                'VII': 'diminished'
            },
            melodic_minor: {
                'I': 'minor',
                'II': 'minor',
                'III': 'augmented',
                'IV': 'major',
                'V': 'major',
                'VI': 'diminished',
                'VII': 'diminished'
            },
            dorian: {
                'I': 'minor',
                'II': 'minor',
                'III': 'major',
                'IV': 'major',
                'V': 'minor',
                'VI': 'diminished',
                'VII': 'major'
            },
            phrygian: {
                'I': 'minor',
                'II': 'major',
                'III': 'major',
                'IV': 'minor',
                'V': 'diminished',
                'VI': 'major',
                'VII': 'minor'
            },
            lydian: {
                'I': 'major',
                'II': 'major',
                'III': 'minor',
                'IV': 'diminished',
                'V': 'major',
                'VI': 'minor',
                'VII': 'minor'
            },
            mixolydian: {
                'I': 'major',
                'II': 'minor',
                'III': 'diminished',
                'IV': 'major',
                'V': 'minor',
                'VI': 'minor',
                'VII': 'major'
            },
            locrian: {
                'I': 'diminished',
                'II': 'major',
                'III': 'minor',
                'IV': 'minor',
                'V': 'major',
                'VI': 'major',
                'VII': 'minor'
            },
            whole_tone: {
                'I': 'augmented',
                'II': 'augmented',
                'III': 'augmented',
                'IV': 'augmented',
                'V': 'augmented',
                'VI': 'augmented',
                'VII': 'augmented'
            },
            diminished: {
                'I': 'diminished',
                'II': 'diminished',
                'III': 'diminished',
                'IV': 'diminished',
                'V': 'diminished',
                'VI': 'diminished',
                'VII': 'diminished',
                'VIII': 'diminished'
            },
            pentatonic_major: {
                'I': 'major',
                'II': 'major',
                'III': 'minor',
                'IV': 'major',
                'V': 'major'
            },
            pentatonic_minor: {
                'I': 'minor',
                'II': 'minor',
                'III': 'major',
                'IV': 'minor',
                'V': 'minor'
            },
            blues: {
                'I': 'dominant7',
                'II': 'minor',
                'III': 'minor',
                'IV': 'dominant7',
                'V': 'dominant7',
                'VI': 'minor'
            }
        };

        // Enhanced audio samples storage
        const audioSamples = {
            piano: {},
            organ: {}
        };

        // Initialize the UI
        function initUI() {
            const scaleSelect = document.getElementById('scale');
            const keySelect = document.getElementById('key');
            
            // Populate scales
            Object.keys(SCALES).forEach(scale => {
                const option = document.createElement('option');
                option.value = scale;
                option.textContent = scale.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                scaleSelect.appendChild(option);
            });
            
            // Populate keys
            NOTES.forEach(note => {
                const option = document.createElement('option');
                option.value = note;
                option.textContent = note;
                keySelect.appendChild(option);
            });
            
            createKeyboard();
            
            // Update when scale changes
            scaleSelect.addEventListener('change', () => {
                updateKeyboard();
                const progressionOutput = document.getElementById('progressionOutput');
                if (progressionOutput.textContent.trim() !== '') {
                    // Regenerate the progression with new scale
                    generateProgression();
                }
            });
            
            // Update when key changes
            keySelect.addEventListener('change', () => {
                updateKeyboard();
                const progressionOutput = document.getElementById('progressionOutput');
                if (progressionOutput.textContent.trim() !== '') {
                    updateExistingProgression(keySelect.value);
                }
            });
            
            // Set up collapsible sections
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', () => {
                    header.classList.toggle('collapsed');
                });
            });
            
            // Set up mobile tabs
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons and content
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    
                    // Add active class to clicked button and corresponding content
                    button.classList.add('active');
                    const tabId = button.dataset.tab + '-tab';
                    document.getElementById(tabId).classList.add('active');
                    
                    // Redraw keyboard when switching to keyboard tab
                    if (button.dataset.tab === 'keyboard') {
                        setTimeout(() => {
                            createKeyboard();
                            updateKeyboard();
                            updateKeyboardZoom();
                        }, 50);
                    }
                });
            });

            if (window.innerWidth <= 768) {
                // Hide all non-keyboard tab content on initial load on mobile
                document.querySelectorAll('.tab-content:not(#keyboard-tab)').forEach(content => {
                    content.classList.remove('active');
                });
            }
            
            // Set up zoom controls
            document.getElementById('zoomInBtn').addEventListener('click', () => {
                if (keyboardZoom < 1.5) {
                    keyboardZoom += 0.1;
                    updateKeyboardZoom();
                }
            });
            
            document.getElementById('zoomOutBtn').addEventListener('click', () => {
                if (keyboardZoom > 0.6) {
                    keyboardZoom -= 0.1;
                    updateKeyboardZoom();
                }
            });
            
            // Set up history button
            document.getElementById('historyBtn').addEventListener('click', showHistoryModal);
            document.querySelector('.close-modal').addEventListener('click', hideHistoryModal);
            
            // Set up progression type change
            document.getElementById('progressionType').addEventListener('change', function() {
                const customInput = document.getElementById('customProgressionInput');
                customInput.style.display = this.value === 'custom' ? 'block' : 'none';
            });
            
            // Setup audio settings
            document.getElementById('soundType').addEventListener('change', function() {
                currentSoundType = this.value;
                if (currentSoundType !== 'sine' && !Object.keys(audioSamples[currentSoundType]).length) {
                    // Preload samples if not already loaded
                    preloadAudioSamples(currentSoundType);
                }
            });
            
            // Setup enhanced audio toggle
            document.getElementById('advancedAudioMode').addEventListener('change', function() {
                enhancedAudio = this.checked;
                if (enhancedAudio && currentSoundType !== 'sine' && !Object.keys(audioSamples[currentSoundType]).length) {
                    preloadAudioSamples(currentSoundType);
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
            
            updateKeyboard();
        }

        function updateKeyboardZoom() {
            const keyboard = document.getElementById('keyboard');
            const container = document.querySelector('.keyboard-wrapper');
            
            // Adjust zoom for mobile devices
            if (window.innerWidth <= 768) {
                keyboardZoom = Math.min(keyboardZoom, 1.0);
            }
            
            keyboard.style.transform = `scale(${keyboardZoom})`;
            keyboard.style.transformOrigin = 'center top';
            
            // Ensure proper scrolling if keyboard is wider than container
            if (keyboard.scrollWidth * keyboardZoom > container.clientWidth) {
                container.style.overflowX = 'auto';
            } else {
                container.style.overflowX = 'hidden';
            }
        }

        function handleKeyboardShortcuts(e) {
            // Prevent action when typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            // Space bar to play/stop progression
            if (e.code === 'Space') {
                e.preventDefault();
                const playBtn = document.getElementById('playProgressionBtn');
                if (playBtn) playBtn.click();
            }
            
            // G key to generate new progression
            if (e.code === 'KeyG') {
                e.preventDefault();
                generateProgression();
            }
            
            // Arrow keys to navigate between chords during playback
            if (isPlaying && (e.code === 'ArrowLeft' || e.code === 'ArrowRight')) {
                e.preventDefault();
                if (progressionInterval) {
                    clearInterval(progressionInterval);
                    
                    const chordItems = document.querySelectorAll('.chord-item');
                    let currentIndex = -1;
                    
                    // Find current playing chord
                    chordItems.forEach((item, index) => {
                        if (item.classList.contains('playing')) {
                            currentIndex = index;
                        }
                    });
                    
                    if (currentIndex >= 0) {
                        // Remove playing class from all
                        chordItems.forEach(item => item.classList.remove('playing'));
                        
                        // Calculate new index
                        let newIndex;
                        if (e.code === 'ArrowLeft') {
                            newIndex = (currentIndex - 1 + chordItems.length) % chordItems.length;
                        } else {
                            newIndex = (currentIndex + 1) % chordItems.length;
                        }
                        
                        // Play the new chord
                        const chordNotesText = chordItems[newIndex].querySelector('.chord-notes').textContent;
                        const notesMatch = chordNotesText.match(/Notes: (([A-G]#?2?)(, [A-G]#?2?)*)/);
                        const chordNotes = notesMatch ? notesMatch[1].split(', ') : [];
                        playChord(chordNotes);
                        chordItems[newIndex].classList.add('playing');
                        
                        // Resume playback from new position
                        const tempo = document.getElementById('tempoSelect').value;
                        const interval = 60000 / tempo;
                        let nextIndex = (newIndex + 1) % chordItems.length;
                        
                        progressionInterval = setInterval(() => {
                            if (!isPlaying) return;
                            
                            chordItems.forEach(item => item.classList.remove('playing'));
                            
                            const chord = chordItems[nextIndex];
                            const chordNotesText = chord.querySelector('.chord-notes').textContent;
                            const notesMatch = chordNotesText.match(/Notes: ([^:]+)/);
                            const notes = notesMatch ? notesMatch[1].split(', ') : [];
                            
                            playChord(notes);
                            chord.classList.add('playing');
                            
                            nextIndex = (nextIndex + 1) % chordItems.length;
                        }, interval);
                    }
                }
            }
        }

        function showHistoryModal() {
            const modal = document.getElementById('historyModal');
            const historyList = document.getElementById('historyList');
            
            // Clear current history list
            historyList.innerHTML = '';
            
            // Add history items
            progressionHistory.forEach((item, index) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.innerHTML = `
                    <strong>${item.key} ${item.scale}</strong>
                    <div>${item.progressionName}</div>
                    <div>${item.chords.join(' → ')}</div>
                `;
                
                // Add click event to load this progression
                historyItem.addEventListener('click', () => {
                    loadProgressionFromHistory(index);
                    hideHistoryModal();
                });
                
                historyList.appendChild(historyItem);
            });
            
            // Show the modal
            modal.style.display = 'flex';
        }

        function hideHistoryModal() {
            const modal = document.getElementById('historyModal');
            modal.style.display = 'none';
        }

        function loadProgressionFromHistory(index) {
            const item = progressionHistory[index];
            
            // Set scale and key
            document.getElementById('scale').value = item.scaleValue;
            document.getElementById('key').value = item.key;
            
            // Set progression type
            const progressionType = document.getElementById('progressionType');
            progressionType.value = item.progressionType;
            
            // Set chord options
            document.getElementById('seventhMode').checked = item.useSevenths;
            document.getElementById('advancedMode').checked = item.useAdvanced;
            document.getElementById('chordCount').value = item.chordCount;
            
            // Update keyboard
            updateKeyboard();
            
            // Display the progression
            updateProgressionDisplay(item.chordDetails);
        }

        function preloadAudioSamples(type) {
            // This would typically load audio samples from a server
            // For this implementation, we'll just create a placeholder
            console.log(`Preloading ${type} samples`);
            
            // In a real implementation, we would load audio files here
            // For now, we'll just create placeholders for the concept
            NOTES.forEach(note => {
                audioSamples[type][note] = `${type}-${note}`;
                audioSamples[type][note + '2'] = `${type}-${note}2`;
            });
        }

        function initAudioContext() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Add a notification for mobile devices that might need interaction
                    if (audioContext.state === 'suspended' && /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                        const notification = document.createElement('div');
                        notification.style.position = 'fixed';
                        notification.style.bottom = '20px';
                        notification.style.left = '50%';
                        notification.style.transform = 'translateX(-50%)';
                        notification.style.padding = '10px 20px';
                        notification.style.background = 'var(--root-color)';
                        notification.style.borderRadius = '4px';
                        notification.style.zIndex = '1000';
                        notification.textContent = 'Tap anywhere to enable audio';
                        document.body.appendChild(notification);
                        
                        document.addEventListener('touchstart', function onTouch() {
                            audioContext.resume();
                            document.removeEventListener('touchstart', onTouch);
                            notification.remove();
                        }, { once: true });
                    }
                } else if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            } catch (e) {
                console.error('Web Audio API is not supported in this browser');
                alert('Your browser does not support Web Audio API. Some features may not work.');
            }
        }

        function playEnhancedNote(note, duration = 1.5, delay = 0) {
            if (!audioContext) {
                initAudioContext();
            }
            
            const baseFreq = NOTE_FREQUENCIES[note];
            if (!baseFreq) return;
            
            const now = audioContext.currentTime + delay;
            
            // Create nodes
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();
            
            // Set up filter
            filterNode.type = 'lowpass';
            filterNode.frequency.setValueAtTime(1500, now);
            filterNode.Q.setValueAtTime(0.5, now);
            
            // Configure oscillator based on sound type
            if (currentSoundType === 'sine') {
                oscillator.type = 'sine';
            } else if (currentSoundType === 'piano') {
                oscillator.type = 'triangle';
                // Add a second oscillator for harmonic richness
                const harmonicOsc = audioContext.createOscillator();
                harmonicOsc.type = 'sine';
                harmonicOsc.frequency.setValueAtTime(baseFreq * 2, now); // Octave up
                
                const harmonicGain = audioContext.createGain();
                harmonicGain.gain.setValueAtTime(0.2, now);
                
                harmonicOsc.connect(harmonicGain);
                harmonicGain.connect(filterNode);
                
                harmonicOsc.start(now);
                harmonicOsc.stop(now + duration);
            } else if (currentSoundType === 'organ') {
                oscillator.type = 'sawtooth';
                // Add multiple oscillators for organ-like sound
                [0.5, 1.5, 2, 3].forEach(harmonic => {
                    const harmonicOsc = audioContext.createOscillator();
                    harmonicOsc.type = 'sine';
                    harmonicOsc.frequency.setValueAtTime(baseFreq * harmonic, now);
                    
                    const harmonicGain = audioContext.createGain();
                    harmonicGain.gain.setValueAtTime(0.15 / harmonic, now);
                    
                    harmonicOsc.connect(harmonicGain);
                    harmonicGain.connect(filterNode);
                    
                    harmonicOsc.start(now);
                    harmonicOsc.stop(now + duration);
                });
            }
            
            // Set basic oscillator properties
            oscillator.frequency.setValueAtTime(baseFreq, now);
            
            // Set envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.5, now + 0.05);
            
            if (currentSoundType === 'piano') {
                // Faster decay for piano
                gainNode.gain.exponentialRampToValueAtTime(0.05, now + 0.5);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration - 0.1);
            } else if (currentSoundType === 'organ') {
                // Slower decay for organ
                gainNode.gain.exponentialRampToValueAtTime(0.3, now + 0.2);
                gainNode.gain.linearRampToValueAtTime(0.25, now + duration - 0.2);
            } else {
                // Default decay
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration - 0.1);
            }
            
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            
            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(filterNode);
            filterNode.connect(audioContext.destination);
            
            // Start and stop
            oscillator.start(now);
            oscillator.stop(now + duration);
            
            return {
                oscillator,
                gainNode,
                filterNode
            };
        }

        function playNote(note) {
            if (enhancedAudio) {
                playEnhancedNote(note);
            } else {
                if (!audioContext) {
                    initAudioContext();
                }

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                const baseFreq = NOTE_FREQUENCIES[note];
                oscillator.type = currentSoundType === 'sine' ? 'sine' : 
                                 currentSoundType === 'piano' ? 'triangle' : 'sawtooth';
                oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.5);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1.6);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 1.6);
            }

            // Visual feedback with proper color restoration
            const keyElement = document.querySelector(`[data-note="${note}"]`);
            if (keyElement) {
                const originalColor = keyElement.style.backgroundColor;
                keyElement.style.backgroundColor = 'var(--key-active)';
                keyElement.style.boxShadow = '0 0 10px var(--key-active)';
                
                setTimeout(() => {
                    // Get current scale and key for proper color restoration
                    const scale = document.getElementById('scale').value;
                    const key = document.getElementById('key').value;
                    const scaleNotes = getScaleNotes(key, SCALES[scale]);
                    const fifthNotes = getFifthNote(key);
                    const fourthNotes = getFourthNote(key);
                    
                    // Determine the correct color based on note's role
                    let restoredColor;
                    if (note === key || note === key + '2') {
                        restoredColor = 'var(--root-color)';
                    } else if (fifthNotes.includes(note)) {
                        restoredColor = 'var(--fifth-color)';
                    } else if (fourthNotes.includes(note)) {
                        restoredColor = 'var(--fourth-color)';
                    } else if (scaleNotes.includes(note)) {
                        restoredColor = 'var(--scale-color)';
                    } else {
                        restoredColor = keyElement.classList.contains('white') ? 'white' : '#333';
                    }
                    
                    keyElement.style.backgroundColor = restoredColor;
                    keyElement.style.boxShadow = 'none';
                }, 1000);
            }
        }

        function playChord(notes) {
            if (!audioContext) {
                initAudioContext();
            }

            // Sort notes for better voicing
            const sortedNotes = arrangeNotesLinearly(notes);

            // Reset all key highlighting
            document.querySelectorAll('.key').forEach(key => {
                const scale = document.getElementById('scale').value;
                const baseKey = document.getElementById('key').value;
                const scaleNotes = getScaleNotes(baseKey, SCALES[scale]);
                const fifthNotes = getFifthNote(baseKey);
                const fourthNotes = getFourthNote(baseKey);
                
                const note = key.dataset.note;
                let color;
                if (note === baseKey || note === baseKey + '2') {
                    color = 'var(--root-color)';
                } else if (fifthNotes.includes(note)) {
                    color = 'var(--fifth-color)';
                } else if (fourthNotes.includes(note)) {
                    color = 'var(--fourth-color)';
                } else if (scaleNotes.includes(note)) {
                    color = 'var(--scale-color)';
                } else {
                    color = key.classList.contains('white') ? 'white' : '#333';
                }
                key.style.backgroundColor = color;
            });

            if (enhancedAudio) {
                // Enhanced playback with staggered start for arpeggio effect
                sortedNotes.forEach((note, index) => {
                    playEnhancedNote(note, 2.0, index * 0.04);
                });
            } else {
                // Standard playback
                sortedNotes.forEach((note, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    const baseFreq = NOTE_FREQUENCIES[note];
                    if (!baseFreq) {
                        console.warn(`Frequency not found for note: ${note}`);
                        return;
                    }
                    
                    const baseVolume = 0.3;
                    const volumeAdjust = index === 0 ? 1 : 0.8;
                    
                    oscillator.type = currentSoundType === 'sine' ? 'sine' : 
                                     currentSoundType === 'piano' ? 'triangle' : 'sawtooth';
                    oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                    
                    const startTime = audioContext.currentTime + (index * 0.02);
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(baseVolume * volumeAdjust, startTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 2.0);
                    gainNode.gain.linearRampToValueAtTime(0, startTime + 2.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + 2.2);
                });
            }

            // Highlight keys for visual feedback
            sortedNotes.forEach((note, index) => {
                const keyElement = document.querySelector(`[data-note="${note}"]`);
                if (keyElement) {
                    keyElement.style.backgroundColor = 'var(--key-active)';
                    keyElement.style.boxShadow = '0 0 10px var(--key-active)';
                    keyElement.style.transform = 'translateY(2px)';
                    
                    // Reset after the note duration with proper color
                    setTimeout(() => {
                        const scale = document.getElementById('scale').value;
                        const baseKey = document.getElementById('key').value;
                        const scaleNotes = getScaleNotes(baseKey, SCALES[scale]);
                        const fifthNotes = getFifthNote(baseKey);
                        const fourthNotes = getFourthNote(baseKey);
                        
                        let restoredColor;
                        if (note === baseKey || note === baseKey + '2') {
                            restoredColor = 'var(--root-color)';
                        } else if (fifthNotes.includes(note)) {
                            restoredColor = 'var(--fifth-color)';
                        } else if (fourthNotes.includes(note)) {
                            restoredColor = 'var(--fourth-color)';
                        } else if (scaleNotes.includes(note)) {
                            restoredColor = 'var(--scale-color)';
                        } else {
                            restoredColor = keyElement.classList.contains('white') ? 'white' : '#333';
                        }
                        
                        keyElement.style.backgroundColor = restoredColor;
                        keyElement.style.boxShadow = 'none';
                        keyElement.style.transform = 'translateY(0)';
                    }, 2000);
                }
            });
        }

        function arrangeNotesLinearly(notes) {
            // First, normalize all notes to their base form (without octave)
            const baseNotes = notes.map(note => note.replace('2', ''));
            const uniqueBaseNotes = [...new Set(baseNotes)];
            
            // Get the root note (first note) and its index
            const rootNote = uniqueBaseNotes[0];
            const rootIndex = NOTES.indexOf(rootNote);
            
            // Sort remaining notes by their interval from the root
            const remainingNotes = uniqueBaseNotes.slice(1).sort((a, b) => {
                const aInterval = (NOTES.indexOf(a) - rootIndex + 12) % 12;
                const bInterval = (NOTES.indexOf(b) - rootIndex + 12) % 12;
                return aInterval - bInterval;
            });
            
            // Start with root note
            const voicedNotes = [rootNote];
            
            // Handle all additional notes with the same wrap-around logic
            remainingNotes.forEach(note => {
                const noteIndex = NOTES.indexOf(note);
                let shouldBeUpperOctave = false;
                
                // If this note's index is less than root, it wrapped around
                if (noteIndex < rootIndex) {
                    shouldBeUpperOctave = true;
                }
                // For notes after root, check if they're too far ahead
                else {
                    const interval = (noteIndex - rootIndex + 12) % 12;
                    // If adding this interval to root position would exceed octave
                    if (rootIndex + interval >= 12) {
                        shouldBeUpperOctave = true;
                    }
                }
                
                // Add the note with or without octave marking
                if (shouldBeUpperOctave && NOTE_FREQUENCIES[note + '2']) {
                    voicedNotes.push(note + '2');
                } else {
                    voicedNotes.push(note);
                }
            });
            
            return voicedNotes;
        }

        function playProgression() {
            const chordItems = document.querySelectorAll('.chord-item');
            if (!chordItems.length) return;
            
            const playButton = document.getElementById('playProgressionBtn');
            const tempo = parseInt(document.getElementById('tempoSelect').value);
            const interval = 60000 / tempo; // Convert BPM to milliseconds
            
            // Toggle play/pause
            if (!isPlaying) {
                let currentChordIndex = 0;
                
                // Start playing
                isPlaying = true;
                playButton.innerHTML = '⏹ <span>Stop</span>';
                playButton.classList.add('playing');
                
                // Create metronome indicators if they don't exist
                if (!document.querySelector('.metronome')) {
                    const metronomeContainer = document.createElement('div');
                    metronomeContainer.style.display = 'flex';
                    metronomeContainer.style.gap = '5px';
                    metronomeContainer.style.marginLeft = '10px';
                    
                    for (let i = 0; i < 4; i++) {
                        const beat = document.createElement('div');
                        beat.className = 'metronome';
                        metronomeContainer.appendChild(beat);
                    }
                    
                    playButton.appendChild(metronomeContainer);
                }
                
                // Beat counter for metronome
                let beatCount = 0;
                
                // Function to play next chord
                const playNextChord = () => {
                    if (!isPlaying) return;
                    
                    // Update metronome visual
                    document.querySelectorAll('.metronome').forEach((beat, i) => {
                        beat.classList.toggle('active', i === beatCount);
                    });
                    beatCount = (beatCount + 1) % 4;
                    
                    // Reset previous chord's visual state
                    chordItems.forEach(item => item.classList.remove('playing'));
                    
                    // Play current chord
                    const currentChord = chordItems[currentChordIndex];
                    const chordNotesText = currentChord.querySelector('.chord-notes').textContent;
                    const notesMatch = chordNotesText.match(/Notes: (([A-G]#?2?)(, [A-G]#?2?)*)/);
                    const chordNotes = notesMatch ? notesMatch[1].split(', ') : [];
                    
                    playChord(chordNotes);
                    currentChord.classList.add('playing');
                    
                    // Move to next chord
                    currentChordIndex = (currentChordIndex + 1) % chordItems.length;
                };
                
                // Play first chord immediately
                playNextChord();
                
                // Set interval for subsequent chords
                progressionInterval = setInterval(playNextChord, interval);
            } else {
                // Stop playing
                isPlaying = false;
                playButton.innerHTML = '▶ <span>Play</span>';
                playButton.classList.remove('playing');
                clearInterval(progressionInterval);
                progressionInterval = null;
                
                // Reset metronome
                document.querySelectorAll('.metronome').forEach(beat => {
                    beat.classList.remove('active');
                });
                
                // Reset all visual states
                chordItems.forEach(item => item.classList.remove('playing'));
                document.querySelectorAll('.key').forEach(key => {
                    key.style.transform = 'translateY(0)';
                });
            }
        }

        function createKeyboard() {
            const keyboard = document.getElementById('keyboard');
            keyboard.innerHTML = ''; // Clear existing keys
            
            const containerWidth = keyboard.clientWidth - 20; // Account for padding
            const isMobile = window.innerWidth <= 768;
            const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const blackKeys = ['C#', 'D#', 'F#', 'G#', 'A#'];
            
            // Calculate key width based on container and device
            let whiteKeyWidth;
            if (isMobile) {
                // On mobile, make sure keys are at least 24px wide for touch targets
                whiteKeyWidth = Math.max(24, Math.min(30, containerWidth / 14));
            } else {
                // On desktop, allow larger keys
                whiteKeyWidth = Math.min(35, containerWidth / 14);
            }
            
            const blackKeyWidth = whiteKeyWidth * 0.6;
            
            // Calculate total width of all keys to center them
            const totalKeyboardWidth = whiteKeyWidth * 14; // 14 white keys in 2 octaves
            
            // Only center if we have enough space
            const offsetToCenter = (containerWidth >= totalKeyboardWidth) 
                ? (containerWidth - totalKeyboardWidth) / 2 
                : 0;
            
            // Create two octaves
            for (let octave = 0; octave < 2; octave++) {
                // White keys
                whiteKeys.forEach((note, i) => {
                    const key = document.createElement('div');
                    key.className = 'key white';
                    key.dataset.note = octave === 0 ? note : note + '2';
                    key.style.left = `${offsetToCenter + (i + octave * 7) * whiteKeyWidth}px`;
                    key.style.width = `${whiteKeyWidth}px`;
                    
                    // Store original color
                    key.dataset.originalColor = 'white';
                    
                    // Add touch and mouse event listeners
                    addKeyEventListeners(key);
                    
                    keyboard.appendChild(key);
                });
                
                // Black keys
                blackKeys.forEach((note, i) => {
                    const key = document.createElement('div');
                    key.className = 'key black';
                    key.dataset.note = octave === 0 ? note : note + '2';
                    const offset = [1, 2, 4, 5, 6][i];
                    key.style.left = `${offsetToCenter + (offset + octave * 7) * whiteKeyWidth - (blackKeyWidth/2)}px`;
                    key.style.width = `${blackKeyWidth}px`;
                    
                    // Store original color
                    key.dataset.originalColor = '#333';
                    
                    // Add touch and mouse event listeners
                    addKeyEventListeners(key);
                    
                    keyboard.appendChild(key);
                });
            }
            
            // Set appropriate width to ensure all keys are visible
            if (isMobile && containerWidth < totalKeyboardWidth) {
                keyboard.style.width = `${totalKeyboardWidth + 20}px`; // Add padding
            } else {
                keyboard.style.width = '100%';
            }
        }

        function updateKeyColor(key) {
            const scale = document.getElementById('scale').value;
            const baseKey = document.getElementById('key').value;
            const scaleNotes = getScaleNotes(baseKey, SCALES[scale]);
            const fifthNotes = getFifthNote(baseKey);
            const fourthNotes = getFourthNote(baseKey);
            
            const note = key.dataset.note;
            
            if (note === baseKey || note === baseKey + '2') {
                key.style.backgroundColor = 'var(--root-color)';
            } else if (fifthNotes.includes(note)) {
                key.style.backgroundColor = 'var(--fifth-color)';
            } else if (fourthNotes.includes(note)) {
                key.style.backgroundColor = 'var(--fourth-color)';
            } else if (scaleNotes.includes(note)) {
                key.style.backgroundColor = 'var(--scale-color)';
            } else {
                key.style.backgroundColor = key.classList.contains('white') ? 'white' : '#333';
            }
        }

        function addKeyEventListeners(key) {
            // Track if the key is currently being pressed
            let isPressed = false;
            
            // Function to handle key press
            const handleKeyPress = (e) => {
                if (!isPressed) {
                    isPressed = true;
                    playNote(key.dataset.note);
                    key.style.backgroundColor = 'var(--key-active)';
                    key.style.boxShadow = '0 0 10px var(--key-active)';
                    key.style.transform = 'translateY(2px)';
                }
                // Prevent default behavior to avoid unwanted effects
                e.preventDefault();
            };
            
            // Function to handle key release
            const handleKeyRelease = () => {
                if (isPressed) {
                    isPressed = false;
                    // Reset key appearance
                    updateKeyColor(key);
                    key.style.boxShadow = 'none';
                    key.style.transform = 'translateY(0)';
                }
            };
            
            // Mouse events
            key.addEventListener('mousedown', handleKeyPress);
            key.addEventListener('mouseup', handleKeyRelease);
            key.addEventListener('mouseleave', handleKeyRelease);
            
            // Touch events with passive: false for better mobile performance
            key.addEventListener('touchstart', handleKeyPress, { passive: false });
            key.addEventListener('touchend', handleKeyRelease);
            key.addEventListener('touchcancel', handleKeyRelease);
            
            // Prevent context menu on long press
            key.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function updateKeyboard() {
            const scale = document.getElementById('scale').value;
            const key = document.getElementById('key').value;
            const scaleNotes = getScaleNotes(key, SCALES[scale]);
            const fifthNotes = getFifthNote(key);
            const fourthNotes = getFourthNote(key);
            
            // Update complementary keys display
            const complementaryKeySpan = document.querySelector('#complementaryKeyInfo');
            const fourthKeySpan = document.querySelector('#fourthKeyInfo');
            
            if (complementaryKeySpan) {
                complementaryKeySpan.textContent = fifthNotes[0];
                complementaryKeySpan.style.color = 'var(--fifth-color)';
            }
            
            if (fourthKeySpan) {
                fourthKeySpan.textContent = fourthNotes[0];
                fourthKeySpan.style.color = 'var(--fourth-color)';
            }
            
            // Update keyboard visualization
            document.querySelectorAll('.key').forEach(keyElement => {
                updateKeyColor(keyElement);
            });
            
            // Update existing progression if one exists
            const progressionOutput = document.getElementById('progressionOutput');
            if (progressionOutput.textContent.trim() !== '') {
                updateExistingProgression(key);
            }
        }

        function getScaleNotes(key, intervals) {
            const keyIndex = NOTES.indexOf(key);
            // Get first octave
            const firstOctave = intervals.map(interval => 
                NOTES[(keyIndex + interval) % 12]
            );
            // Get second octave
            const secondOctave = intervals.map(interval => 
                NOTES[(keyIndex + interval) % 12] + '2'
            );
            return [...firstOctave, ...secondOctave];
        }

        function getFifthNote(key) {
            const keyIndex = NOTES.indexOf(key);
            const firstOctave = NOTES[(keyIndex + 7) % 12];
            const secondOctave = NOTES[(keyIndex + 7) % 12] + '2';
            return [firstOctave, secondOctave];
        }

        function getFourthNote(key) {
            const keyIndex = NOTES.indexOf(key);
            const firstOctave = NOTES[(keyIndex + 5) % 12];
            const secondOctave = NOTES[(keyIndex + 5) % 12] + '2';
            return [firstOctave, secondOctave];
        }

        function isNoteInScale(note, scale, key) {
            const baseNote = note.replace('2', ''); // Remove octave designation
            const scaleNotes = getScaleNotes(key, SCALES[scale]).map(n => n.replace('2', ''));
            return scaleNotes.includes(baseNote);
        }
        
        function getRomanNumeralChord(degree, scale, modes) {
            // Get base scale type
            const scaleType = scale in SCALE_CHORD_QUALITIES ? scale : (scale.includes('minor') ? 'minor' : 'major');
            const scaleQualities = SCALE_CHORD_QUALITIES[scaleType] || SCALE_CHORD_QUALITIES.major;
            
            // Extract degree without modifiers for quality lookup
            const baseDegree = degree.replace(/[b#°]|[0-9]+/g, '').toUpperCase();
            
            // Determine quality based on scale context first
            let quality = scaleQualities[baseDegree] || 'major';
            
            // Special case for diminished chords marked with ° symbol
            if (degree.includes('°')) {
                quality = 'diminished';
            } else if (degree.includes('+')) {
                quality = 'augmented';
            } else {
                // Override based on case if it's explicitly notated
                const isLowerCase = degree !== degree.toUpperCase();
                const isUpperCase = degree !== degree.toLowerCase();
                
                if (isLowerCase && isUpperCase) {
                    // Mixed case, use original quality from scale
                } else if (isLowerCase && quality !== 'diminished' && quality !== 'augmented') {
                    quality = 'minor'; // Force lowercase to be minor
                } else if (isUpperCase && quality !== 'diminished' && quality !== 'augmented') {
                    quality = 'major'; // Force uppercase to be major
                }
            }
            
            // Special cases for certain scales
            const forceHarmonicFunction = (scale.includes('harmonic_minor') || scale.includes('melodic_minor')) && baseDegree === 'V';
            if (forceHarmonicFunction) {
                quality = 'major'; // Force V to be major in harmonic/melodic minor
            }

            // Return intervals based on chord quality and modes
            if (modes.advanced && modes.seventh) {
                // Extended chord (9th/11th)
                switch (quality) {
                    case 'major':
                        return forceHarmonicFunction ? CHORD_TYPES.extended.dom9 :
                            Math.random() > 0.5 ? CHORD_TYPES.extended.maj9 : CHORD_TYPES.extended.maj11;
                    case 'minor':
                        return Math.random() > 0.5 ? CHORD_TYPES.extended.min9 : CHORD_TYPES.extended.min11;
                    case 'diminished':
                        return CHORD_TYPES.seventh.halfDim7; // Half-diminished in extended context
                    case 'augmented':
                        return CHORD_TYPES.extended.dom9; // Default to dominant extensions for augmented
                    default:
                        return CHORD_TYPES.extended.dom9;
                }
            } else if (modes.seventh) {
                // Seventh chord
                switch (quality) {
                    case 'major':
                        return forceHarmonicFunction ? CHORD_TYPES.seventh.dom7 : CHORD_TYPES.seventh.major7;
                    case 'minor':
                        return CHORD_TYPES.seventh.minor7;
                    case 'diminished':
                        return CHORD_TYPES.seventh.halfDim7;
                    case 'augmented':
                        return CHORD_TYPES.seventh.dom7; // Augmented often functions as dominant
                    default:
                        return CHORD_TYPES.seventh.dom7;
                }
            } else {
                // Triad
                switch (quality) {
                    case 'major':
                        return CHORD_TYPES.triad.major;
                    case 'minor':
                        return CHORD_TYPES.triad.minor;
                    case 'diminished':
                        return CHORD_TYPES.triad.diminished;
                    case 'augmented':
                        return CHORD_TYPES.triad.augmented;
                    default:
                        return CHORD_TYPES.triad.major;
                }
            }
        }

        function getProperRomanNumeral(degree, scale) {
            // Extract scale type
            const scaleType = scale in SCALE_CHORD_QUALITIES ? scale : (scale.includes('minor') ? 'minor' : 'major');
            const scaleQualities = SCALE_CHORD_QUALITIES[scaleType] || SCALE_CHORD_QUALITIES.major;
            
            // Get the quality for this degree
            const quality = scaleQualities[degree] || 'major';
            
            // Apply proper case based on quality
            if (quality === 'major' || quality === 'augmented') {
                return degree.toUpperCase(); // Major chords are uppercase
            } else if (quality === 'minor' || quality === 'diminished') {
                return degree.toLowerCase(); // Minor and diminished are lowercase
            }
            
            return degree; // Default fallback
        }

        function romanToNote(roman, key, scale) {
            const scaleNotes = getScaleNotes(key, SCALES[scale]);
            const degreeMap = {
                'I': 0,
                'II': 1,
                'III': 2,
                'IV': 3,
                'V': 4,
                'VI': 5,
                'VII': 6,
                'i': 0,
                'ii': 1,
                'iii': 2,
                'iv': 3,
                'v': 4,
                'vi': 5,
                'vii': 6
            };
            
            const degree = degreeMap[roman];
            if (degree === undefined) return key; // Default to key if invalid roman numeral
            
            return scaleNotes[degree % scaleNotes.length];
        }

        function getChordNotes(root, chord, octaveHandling = true, enforceScale = true) {
            const scale = document.getElementById('scale').value;
            const key = document.getElementById('key').value;
            const rootIndex = NOTES.indexOf(root);
            
            // Make sure we can find the root
            if (rootIndex === -1) return [root];
            
            // Get all scale notes for reference
            const scaleNotes = SCALES[scale].map(interval => NOTES[(NOTES.indexOf(key) + interval) % 12]);
            
            // Apply intervals to the root with modifications for scale-conformity
            const notes = chord.map(interval => {
                const noteIndex = (rootIndex + interval) % 12;
                const note = NOTES[noteIndex];
                
                // Create diatonic adjustments only when necessary
                if (enforceScale && !scaleNotes.includes(note)) {
                    // Check for special cases where we want to keep non-scale notes
                    
                    // Case 1: Minor third (flat third) for minor chords
                    if (interval === 3 && (chord === CHORD_TYPES.triad.minor || 
                                        chord === CHORD_TYPES.seventh.minor7 || 
                                        chord === CHORD_TYPES.extended.min9 || 
                                        chord === CHORD_TYPES.extended.min11)) {
                        return note; // Always keep the minor third
                    }
                    
                    // Case 2: Major third (natural third) for major chords
                    if (interval === 4 && (chord === CHORD_TYPES.triad.major || 
                                        chord === CHORD_TYPES.seventh.major7 || 
                                        chord === CHORD_TYPES.seventh.dom7 ||
                                        chord === CHORD_TYPES.extended.maj9 || 
                                        chord === CHORD_TYPES.extended.maj11 ||
                                        chord === CHORD_TYPES.extended.dom9)) {
                        return note; // Always keep the major third
                    }
                    
                    // Case 3: Augmented fifth (sharp 5th)
                    if (interval === 8 && chord === CHORD_TYPES.triad.augmented) {
                        return note; // Always keep the augmented fifth
                    }
                    
                    // Case 4: Diminished fifth (flat 5th)
                    if (interval === 6 && (chord === CHORD_TYPES.triad.diminished || 
                                        chord === CHORD_TYPES.seventh.halfDim7 ||
                                        chord === CHORD_TYPES.seventh.dim7)) {
                        return note; // Always keep the diminished fifth
                    }
                    
                    // Case 5: Leading tone in minor keys (harmonic minor function)
                    if (scale.includes('minor') && interval === 11 && 
                        (chord === CHORD_TYPES.seventh.dom7 || chord === CHORD_TYPES.seventh.major7)) {
                        return note; // Keep the leading tone
                    }
                    
                    // Case 6: Dominant 7th flattened seventh
                    if (interval === 10 && (chord === CHORD_TYPES.seventh.dom7 || 
                                        chord === CHORD_TYPES.extended.dom9)) {
                        return note; // Keep the dominant 7th
                    }
                    
                    // Case 7: Major 7th for major seventh chords
                    if (interval === 11 && (chord === CHORD_TYPES.seventh.major7 || 
                                        chord === CHORD_TYPES.extended.maj9 ||
                                        chord === CHORD_TYPES.extended.maj11)) {
                        return note; // Keep the major 7th
                    }
                    
                    // Case 8: Minor 7th for minor seventh chords
                    if (interval === 10 && (chord === CHORD_TYPES.seventh.minor7 || 
                                        chord === CHORD_TYPES.extended.min9 ||
                                        chord === CHORD_TYPES.extended.min11)) {
                        return note; // Keep the minor 7th
                    }
                    
                    // Case 9: Diminished seventh (double flat 7th)
                    if (interval === 9 && chord === CHORD_TYPES.seventh.dim7) {
                        return note; // Keep the diminished seventh
                    }
                    
                    // Find closest scale note (default behavior)
                    const distances = scaleNotes.map(scaleNote => {
                        const scaleIndex = NOTES.indexOf(scaleNote);
                        return Math.min(
                            Math.abs(noteIndex - scaleIndex),
                            Math.abs(noteIndex - scaleIndex + 12),
                            Math.abs(noteIndex - scaleIndex - 12)
                        );
                    });
                    const closestIndex = distances.indexOf(Math.min(...distances));
                    return scaleNotes[closestIndex];
                }
                
                return note;
            });
            
            // Handle octave notation for better voicing
            if (octaveHandling) {
                return notes.map((note, index) => {
                    const noteIndex = NOTES.indexOf(note);
                    const interval = (noteIndex - rootIndex + 12) % 12;
                    
                    // Use octave notation for high intervals or wrap-around
                    if (interval > 7 || (noteIndex < rootIndex && index > 0)) {
                        return note + '2';
                    }
                    return note;
                });
            }
            
            return notes;
        }

        function getChordName(root, chordType) {
            // Basic quality abbreviations
            if (chordType === CHORD_TYPES.triad.major) return root;
            if (chordType === CHORD_TYPES.triad.minor) return root + 'm';
            if (chordType === CHORD_TYPES.triad.diminished) return root + 'dim';
            if (chordType === CHORD_TYPES.triad.augmented) return root + 'aug';
            
            // Seventh chords
            if (chordType === CHORD_TYPES.seventh.major7) return root + 'maj7';
            if (chordType === CHORD_TYPES.seventh.minor7) return root + 'm7';
            if (chordType === CHORD_TYPES.seventh.dom7) return root + '7';
            if (chordType === CHORD_TYPES.seventh.halfDim7) return root + 'm7b5';
            if (chordType === CHORD_TYPES.seventh.dim7) return root + 'dim7';
            
            // Extended chords
            if (chordType === CHORD_TYPES.extended.maj9) return root + 'maj9';
            if (chordType === CHORD_TYPES.extended.min9) return root + 'm9';
            if (chordType === CHORD_TYPES.extended.dom9) return root + '9';
            if (chordType === CHORD_TYPES.extended.maj11) return root + 'maj11';
            if (chordType === CHORD_TYPES.extended.min11) return root + 'm11';
            
            // Default case - just return root name
            return root;
        }

        function generateProgression() {
            // Clear any existing progression playback
            if (progressionInterval) {
                clearInterval(progressionInterval);
                progressionInterval = null;
                isPlaying = false;
            }
            
            const scale = document.getElementById('scale').value;
            const key = document.getElementById('key').value;
            const chordCount = parseInt(document.getElementById('chordCount').value);
            const progressionType = document.getElementById('progressionType').value;
            
            const modes = {
                seventh: document.getElementById('seventhMode').checked,
                advanced: document.getElementById('advancedMode').checked
            };
            
            // Get appropriate progression pattern for the scale type
            let progression;
            
            if (progressionType === 'custom') {
                // Parse custom progression
                const customInput = document.getElementById('customProgression').value;
                progression = customInput.split('-').map(deg => deg.trim());
            } else if (progressionType === 'random') {
                // Generate random progression appropriate for scale
                progression = generateRandomProgression(chordCount, scale);
            } else {
                // Use predefined progression
                progression = [...PROGRESSION_TYPES[progressionType]];
                
                // Adjust progression length if needed
                while (progression.length < chordCount) {
                    // Add more chords by repeating the progression
                    progression = [...progression, ...PROGRESSION_TYPES[progressionType]];
                }
                progression = progression.slice(0, chordCount);
                
                // Apply proper notation based on scale
                progression = progression.map(deg => {
                    return getProperRomanNumeral(deg, scale);
                });
                
                // Add proper diminished symbol
                progression = progression.map(deg => {
                    const upperDeg = deg.toUpperCase();
                    if (SCALE_CHORD_QUALITIES[scale] && 
                        SCALE_CHORD_QUALITIES[scale][upperDeg] === 'diminished') {
                        return deg + '°';
                    }
                    return deg;
                });
            }
            
            // Get scale notes for reference
            const scaleNotes = getScaleNotes(key, SCALES[scale]).map(n => n.replace('2', ''));
            
            // Generate chord details for each degree in the progression
            const chordDetails = progression.map(degree => {
                // Get the root note for this degree
                const rootNote = romanToNote(degree, key, scale);
                
                // Music theory based overrides:
                // 1. In minor keys, V and vii° chords often use harmonic minor (major V)
                const useHarmonicMinor = scale.includes('minor') && (degree === 'V' || degree === 'VII' || degree === 'vii');
                
                // Get chord intervals based on the degree, scale and modes
                const chordIntervals = getRomanNumeralChord(degree, scale, modes);
                
                // Get the actual notes for this chord with optional scale enforcement
                const enforceScale = !(useHarmonicMinor || degree.startsWith('N') || degree.includes('/'));
                const notes = getChordNotes(rootNote, chordIntervals, true, enforceScale);
                
                // Get nice name for the chord
                const chordName = getChordName(rootNote, chordIntervals);
                
                return {
                    degree,
                    root: rootNote,
                    notes,
                    name: chordName,
                    // Note music theory exceptions
                    theoreticalContext: useHarmonicMinor ? 'harmonic minor function' : null
                };
            });
            
            // Save to history
            saveProgressionToHistory({
                key: key,
                scale: scale.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
                scaleValue: scale,
                progressionType: progressionType,
                progressionName: getProgressionName(progressionType),
                chords: chordDetails.map(c => c.name),
                chordDetails: chordDetails,
                useSevenths: modes.seventh,
                useAdvanced: modes.advanced,
                chordCount: chordCount
            });
            
            // Display the progression
            updateProgressionDisplay(chordDetails);
            
            // Reset key highlighting
            document.querySelectorAll('.key').forEach(key => {
                updateKeyColor(key);
            });
            
            // Remove any active chord highlighting
            document.querySelectorAll('.chord-item').forEach(item => {
                item.classList.remove('playing');
            });

        }

        function getProgressionName(type) {
            const progressionNames = {
                'basic': 'Basic (I-IV-V)',
                'common': 'Common Pop (I-VI-IV-V)',
                'extended': 'Extended (I-III-VI-IV)',
                'circle': 'Circle of 5ths (VI-II-V-I)',
                'jazz': 'Jazz (II-V-I)',
                'jazz2': 'Jazz II (III-VI-II-V)',
                'random': 'Random',
                'custom': 'Custom'
            };
            
            return progressionNames[type] || 'Custom';
        }

        function saveProgressionToHistory(progression) {
            // Limit history to most recent 10 items
            if (progressionHistory.length >= 10) {
                progressionHistory.pop();
            }
            
            // Add to beginning of history
            progressionHistory.unshift(progression);
        }

        function generateRandomProgression(length, scale = 'major') {
            // Determine if we're in a major or minor context
            const isMinor = scale.includes('minor');
            
            // Choose appropriate degrees based on scale context
            const commonDegrees = isMinor 
                ? ['i', 'ii°', 'III', 'iv', 'v', 'VI', 'VII', 'V'] // Minor with both natural and harmonic options
                : ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii°']; // Major
            
            // Start with the tonic chord
            const progression = [isMinor ? 'i' : 'I'];
            
            // Patterns specific to the scale type
            const commonPatterns = isMinor
                ? [
                    ['iv', 'V'], // Minor plagal cadence with harmonic minor V
                    ['VI', 'VII'], // Subtonic sequence
                    ['ii°', 'V'], // Minor jazz-like
                    ['iv', 'i'], // Minor plagal cadence
                    ['VI', 'iv', 'V'], // Minor pop progression
                    ['i', 'VII', 'VI'], // Descending sequence
                  ]
                : [
                    ['IV', 'V'], // Standard cadence
                    ['vi', 'V'], // Deceptive approach
                    ['ii', 'V'], // Jazz-like
                    ['IV', 'I'], // Plagal cadence
                    ['vi', 'IV', 'V'], // Pop progression
                    ['I', 'V', 'vi', 'IV'], // Axis progression
                  ];
            
            // Add chords until we reach the desired length
            while (progression.length < length) {
                // 70% chance to use a common pattern, 30% chance for random chord
                if (Math.random() < 0.7 && progression.length < length - 1) {
                    // Use a common pattern
                    const pattern = commonPatterns[Math.floor(Math.random() * commonPatterns.length)];
                    
                    // Only add if it doesn't exceed desired length
                    if (progression.length + pattern.length <= length) {
                        progression.push(...pattern);
                    } else {
                        // Just add one random chord
                        const randomDegree = commonDegrees[Math.floor(Math.random() * commonDegrees.length)];
                        progression.push(randomDegree);
                    }
                } else {
                    // Add one random chord
                    const randomDegree = commonDegrees[Math.floor(Math.random() * commonDegrees.length)];
                    progression.push(randomDegree);
                }
            }
            
            // Always end with a strong cadence if possible
            if (progression.length >= 2) {
                if (isMinor) {
                    if (progression[progression.length - 1] !== 'i') {
                        progression[progression.length - 1] = Math.random() > 0.3 ? 'i' : 'I'; // Sometimes use Picardy third
                    }
                    if (progression[progression.length - 2] !== 'V') {
                        progression[progression.length - 2] = 'V'; // Dominant cadence
                    }
                } else {
                    if (progression[progression.length - 1] !== 'I') {
                        progression[progression.length - 1] = 'I';
                    }
                    if (progression[progression.length - 2] !== 'V') {
                        progression[progression.length - 2] = Math.random() > 0.7 ? 'V' : 'IV'; // Mostly dominant, sometimes plagal
                    }
                }
            }
            
            return progression;
        }

        function updateProgressionDisplay(chordDetails) {
            const outputEl = document.getElementById('progressionOutput');
            outputEl.innerHTML = '';

            // Get scale and key info for context
            const scale = document.getElementById('scale').value;
            const key = document.getElementById('key').value;
            const scaleFormatted = scale.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

            // Display current progression info
            const infoDiv = document.createElement('div');
            infoDiv.className = 'progression-info';
            infoDiv.style.marginBottom = '15px';
            
            // Add scale and key info
            infoDiv.innerHTML = `<div class="progression-details">Key: ${key} ${scaleFormatted}</div>`;
            
            // Build chord progression sequence
            const progressionSequence = chordDetails.map(chord => {
                // Return both the degree (roman numeral) and chord name
                return `<span title="${chord.degree}">${chord.name}</span>`;
            }).join(' → ');
            
            infoDiv.innerHTML += `<div class="progression-sequence" style="margin-top: 8px; font-weight: bold;">${progressionSequence}</div>`;
            outputEl.appendChild(infoDiv);

            // Create chord list
            const chordListDiv = document.createElement('div');
            chordListDiv.className = 'chord-list';

            chordDetails.forEach((chord, i) => {
                const chordDiv = document.createElement('div');
                chordDiv.className = 'chord-item';
                chordDiv.tabIndex = 0; // Make focusable for keyboard navigation

                const chordSymbol = document.createElement('div');
                chordSymbol.className = 'chord-symbol';
                chordSymbol.textContent = `Chord ${i + 1} (${chord.degree}): ${chord.name}`;

                const chordNotes = document.createElement('div');
                chordNotes.className = 'chord-notes';
                chordNotes.textContent = `Notes: ${chord.notes.join(', ')}`;
                
                // If there's a theoretical context, add it
                if (chord.theoreticalContext) {
                    const theoryNote = document.createElement('div');
                    theoryNote.className = 'theory-note';
                    theoryNote.textContent = `Note: ${chord.theoreticalContext}`;
                    theoryNote.style.fontSize = "0.85em";
                    theoryNote.style.color = "var(--text-secondary)";
                    theoryNote.style.fontStyle = "italic";
                    chordNotes.appendChild(theoryNote);
                }

                const playButton = document.createElement('button');
                playButton.className = 'play-chord-button';
                playButton.innerHTML = '▶';
                playButton.title = "Play Chord";
                playButton.setAttribute('aria-label', `Play ${chord.name} chord`);
                
                const playChordHandler = () => {
                    playChord(chord.notes);
                    
                    // Highlight this chord
                    document.querySelectorAll('.chord-item').forEach(item => item.classList.remove('playing'));
                    chordDiv.classList.add('playing');
                    setTimeout(() => {
                        chordDiv.classList.remove('playing');
                    }, 1000);
                    
                    // Highlight keyboard keys
                    document.querySelectorAll('.key').forEach(key => {
                        if (chord.notes.includes(key.dataset.note)) {
                            key.style.transform = 'translateY(2px)';
                            setTimeout(() => {
                                key.style.transform = 'translateY(0)';
                            }, 1000);
                        }
                    });
                };
                
                chordDiv.addEventListener('click', playChordHandler);
                chordDiv.addEventListener('keydown', e => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        playChordHandler();
                    }
                });
                
                playButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    playChordHandler();
                });
                
                chordDiv.appendChild(chordSymbol);
                chordDiv.appendChild(chordNotes);
                chordDiv.appendChild(playButton);
                chordListDiv.appendChild(chordDiv);
            });
            
            outputEl.appendChild(chordListDiv);
            
            // Add scale notes reference
            const scaleNotesDiv = document.createElement('div');
            scaleNotesDiv.className = 'scale-notes-reference';
            scaleNotesDiv.style.margin = "20px 0";
            scaleNotesDiv.style.padding = "15px";
            scaleNotesDiv.style.background = "var(--bg-primary)";
            scaleNotesDiv.style.borderRadius = "4px";
            scaleNotesDiv.style.border = "1px solid var(--border-color)";
            
            const scaleNotes = getScaleNotes(key, SCALES[scale]).filter(note => !note.includes('2')); // Remove octave duplicates
            scaleNotesDiv.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px;">${key} ${scaleFormatted} Scale Notes:</div>
                <div>${scaleNotes.join(' - ')}</div>
            `;
            
            outputEl.appendChild(scaleNotesDiv);
            
            // Add play controls
            const playControlsContainer = document.createElement('div');
            playControlsContainer.className = 'play-controls-container';
            
            const tempoContainer = document.createElement('div');
            tempoContainer.className = 'tempo-container';
            
            const tempoSelect = document.createElement('select');
            tempoSelect.id = 'tempoSelect';
            [
                { value: 30, label: 'Slow' },
                { value: 45, label: 'Medium' },
                { value: 60, label: 'Fast' },
                { value: 90, label: 'Very Fast' }
            ].forEach(tempo => {
                const option = document.createElement('option');
                option.value = tempo.value;
                option.textContent = tempo.label;
                if (tempo.value === 45) option.selected = true;
                tempoSelect.appendChild(option);
            });
            
            const tempoLabel = document.createElement('label');
            tempoLabel.htmlFor = 'tempoSelect';
            tempoLabel.textContent = 'Tempo: ';
            
            tempoContainer.appendChild(tempoLabel);
            tempoContainer.appendChild(tempoSelect);
            
            const playButton = document.createElement('button');
            playButton.id = 'playProgressionBtn';
            playButton.innerHTML = '▶ <span>Play</span>';
            playButton.onclick = playProgression;
            
            playControlsContainer.appendChild(tempoContainer);
            playControlsContainer.appendChild(playButton);
            
            outputEl.appendChild(playControlsContainer);
            
            // Add additional suggested progressions section
            addSuggestedProgressions(outputEl, key, scale);
        }

        function applySecondaryDominant(key, scale) {
            // Get the current progression
            const chordItems = document.querySelectorAll('.chord-item');
            if (chordItems.length < 2) return;
            
            // Find a suitable chord to add a secondary dominant before (IV or V)
            let targetIndex = -1;
            for (let i = 0; i < chordItems.length; i++) {
                const chordSymbol = chordItems[i].querySelector('.chord-symbol');
                if (chordSymbol && chordSymbol.textContent.includes('(IV)') || 
                    chordSymbol && chordSymbol.textContent.includes('(V)')) {
                    targetIndex = i;
                    break;
                }
            }
            
            if (targetIndex === -1) targetIndex = 1; // Default to before second chord
            
            // Get all degrees from the current progression
            const newProgression = [];
            chordItems.forEach(item => {
                const chordSymbol = item.querySelector('.chord-symbol');
                const degreeMatch = chordSymbol.textContent.match(/\((.*?)\)/);
                if (degreeMatch) {
                    newProgression.push(degreeMatch[1]);
                }
            });
            
            // Insert the secondary dominant
            const targetDegree = newProgression[targetIndex];
            const secondaryDom = `V/${targetDegree}`;
            newProgression.splice(targetIndex, 0, secondaryDom);
            
            // Update the progression
            generateCustomProgression(newProgression, key, scale);
        }

        function applyTritoneSubstitution(key, scale) {
            // Get the current progression
            const chordItems = document.querySelectorAll('.chord-item');
            if (chordItems.length < 2) return;
            
            // Find dominant (V) chords to substitute
            const newProgression = [];
            let changed = false;
            
            chordItems.forEach(item => {
                const chordSymbol = item.querySelector('.chord-symbol');
                const degreeMatch = chordSymbol.textContent.match(/\((.*?)\)/);
                if (degreeMatch) {
                    const degree = degreeMatch[1];
                    if (degree === 'V') {
                        newProgression.push('bII7');
                        changed = true;
                    } else {
                        newProgression.push(degree);
                    }
                }
            });
            
            if (changed) {
                // Update the progression
                generateCustomProgression(newProgression, key, scale);
            } else {
                alert('No dominant (V) chords found for tritone substitution');
            }
        }

        function applyModalInterchange(key, scale) {
            // Get the current progression
            const chordItems = document.querySelectorAll('.chord-item');
            if (chordItems.length < 2) return;
            
            const isMinor = scale.includes('minor');
            const newProgression = [];
            
            // Get current progression
            chordItems.forEach(item => {
                const chordSymbol = item.querySelector('.chord-symbol');
                const degreeMatch = chordSymbol.textContent.match(/\((.*?)\)/);
                if (degreeMatch) {
                    newProgression.push(degreeMatch[1]);
                }
            });
            
            // Apply modal interchange
            if (isMinor) {
                // In minor key, borrow chords from relative major
                for (let i = 0; i < newProgression.length; i++) {
                    if (newProgression[i] === 'iv') {
                        newProgression[i] = 'IV'; // Use major IV instead of minor iv
                        break;
                    }
                }
            } else {
                // In major key, borrow chords from parallel minor
                for (let i = 0; i < newProgression.length; i++) {
                    if (newProgression[i] === 'IV') {
                        newProgression[i] = 'iv'; // Use minor iv instead of major IV
                        break;
                    }
                    if (newProgression[i] === 'vi' && i < newProgression.length - 1) {
                        newProgression[i] = 'bVI'; // Use flat VI instead of vi
                        break;
                    }
                }
            }
            
            // Update the progression
            generateCustomProgression(newProgression, key, scale);
        }

        function applyExtendedCadence(key, scale) {
            // Get the current progression
            const chordItems = document.querySelectorAll('.chord-item');
            if (chordItems.length < 2) return;
            
            const newProgression = [];
            
            // Get current progression
            chordItems.forEach(item => {
                const chordSymbol = item.querySelector('.chord-symbol');
                const degreeMatch = chordSymbol.textContent.match(/\((.*?)\)/);
                if (degreeMatch) {
                    newProgression.push(degreeMatch[1]);
                }
            });
            
            const isMinor = scale.includes('minor');
            
            // Find where to extend the cadence
            if (newProgression[newProgression.length - 1] === (isMinor ? 'i' : 'I')) {
                // If ending on tonic, replace with extended cadence
                newProgression.pop(); // Remove the last chord
                
                if (isMinor) {
                    newProgression.push('iv', 'V', 'i'); // Minor cadence
                } else {
                    newProgression.push('ii', 'V', 'I'); // Major cadence
                }
            } else {
                // Just add a cadence at the end
                if (isMinor) {
                    newProgression.push('iv', 'V', 'i');
                } else {
                    newProgression.push('ii', 'V', 'I');
                }
            }
            
            // Update the progression
            generateCustomProgression(newProgression, key, scale);
        }

        // Helper function to generate custom progressions
        function generateCustomProgression(degrees, key, scale) {
            // Make sure we have the right modes
            const modes = {
                seventh: document.getElementById('seventhMode').checked,
                advanced: document.getElementById('advancedMode').checked
            };
            
            // Get chord details for each degree
            const chordDetails = degrees.map(degree => {
                // Special handling for secondary dominants
                if (degree.includes('/')) {
                    // Secondary dominant logic
                    const parts = degree.split('/');
                    const rootDegree = parts[1]; // The target chord
                    
                    // Get the root note of the target
                    const targetRoot = romanToNote(rootDegree, key, scale);
                    
                    // Get the fifth of that root (secondary dominant)
                    const targetIndex = NOTES.indexOf(targetRoot.replace('2', ''));
                    const domIndex = (targetIndex + 7) % 12; // Up a fifth
                    const domRoot = NOTES[domIndex];
                    
                    // Create a dominant 7th chord
                    const notes = getChordNotes(domRoot, CHORD_TYPES.seventh.dom7, true, false);
                    const chordName = getChordName(domRoot, CHORD_TYPES.seventh.dom7);
                    
                    return {
                        degree,
                        root: domRoot,
                        notes,
                        name: chordName,
                        theoreticalContext: 'secondary dominant'
                    };
                } 
                // Handle borrowed chords with flats
                else if (degree.startsWith('b')) {
                    const baseDegree = degree.replace('b', '').replace('7', '');
                    const baseRoot = romanToNote(baseDegree, key, scale);
                    
                    // Flatten the root
                    const baseIndex = NOTES.indexOf(baseRoot.replace('2', ''));
                    const flatIndex = (baseIndex - 1 + 12) % 12;
                    const flatRoot = NOTES[flatIndex];
                    
                    // Determine chord type
                    let chordType;
                    if (degree.includes('7')) {
                        chordType = CHORD_TYPES.seventh.dom7;
                    } else {
                        chordType = CHORD_TYPES.triad.major;
                    }
                    
                    // Create the chord
                    const notes = getChordNotes(flatRoot, chordType, true, false);
                    const chordName = getChordName(flatRoot, chordType);
                    
                    return {
                        degree,
                        root: flatRoot,
                        notes,
                        name: chordName,
                        theoreticalContext: 'borrowed chord'
                    };
                } 
                // Regular chord handling
                else {
                    const rootNote = romanToNote(degree, key, scale);
                    
                    // Check for modal interchange
                    const isMajorScale = !scale.includes('minor');
                    const degreeBase = degree.replace(/[b#]|[0-9]/g, ''); // Remove accidentals/numbers
                    const isUpperCase = degreeBase === degreeBase.toUpperCase();
                    const isLowerCase = degreeBase === degreeBase.toLowerCase();
                    const isModalInterchange = (isMajorScale && isLowerCase) || (!isMajorScale && isUpperCase);
                    
                    const useHarmonicMinor = scale.includes('minor') && 
                                            (degree === 'V' || degree === 'VII');
                    
                    const chordIntervals = getRomanNumeralChord(degree, scale, modes);
                    
                    // IMPORTANT FIX: Don't enforce scale for modal interchange chords
                    const enforceScale = !useHarmonicMinor && !isModalInterchange;
                    
                    const notes = getChordNotes(rootNote, chordIntervals, true, enforceScale);
                    const chordName = getChordName(rootNote, chordIntervals);
                    
                    return {
                        degree,
                        root: rootNote,
                        notes,
                        name: chordName,
                        theoreticalContext: useHarmonicMinor ? 'harmonic minor function' : 
                                        isModalInterchange ? 'modal interchange' : null
                    };
                }
            });
            
            // Display the progression
            updateProgressionDisplay(chordDetails);
        }

        
        function addSuggestedProgressions(outputEl, key, scale) {
            const suggestionsDiv = document.createElement('div');
            suggestionsDiv.className = 'suggestions-section';
            suggestionsDiv.style.marginTop = '20px';
            suggestionsDiv.style.padding = '15px';
            suggestionsDiv.style.background = 'var(--bg-secondary)';
            suggestionsDiv.style.borderRadius = '8px';
            suggestionsDiv.style.border = '1px solid var(--border-color)';
            
            const header = document.createElement('h3');
            header.textContent = 'Suggested Substitutions';
            header.style.marginBottom = '10px';
            header.style.fontSize = '1rem';
            
            const suggestionList = document.createElement('div');
            suggestionList.className = 'suggestion-list';
            suggestionList.style.display = 'flex';
            suggestionList.style.flexWrap = 'wrap';
            suggestionList.style.gap = '10px';
            
            // Get a few suggested alternative progressions
            const isMinor = scale.includes('minor');
            const suggestions = [
                {
                    name: 'Add Secondary Dominant',
                    desc: isMinor ? 'V/III (Secondary dominant of relative major)' : 'V/V (Secondary dominant of dominant)',
                    action: applySecondaryDominant
                },
                {
                    name: 'Tritone Substitution',
                    desc: 'Replace dominant with bII7',
                    action: applyTritoneSubstitution
                },
                {
                    name: 'Modal Interchange',
                    desc: isMinor ? 'Borrow chords from relative major' : 'Borrow chords from parallel minor',
                    action: applyModalInterchange
                },
                {
                    name: 'Extended Cadence',
                    desc: 'Expand final cadence',
                    action: applyExtendedCadence
                }
            ];
            
            suggestions.forEach(suggestion => {
                const suggestionButton = document.createElement('button');
                suggestionButton.className = 'suggestion-btn';
                suggestionButton.style.padding = '8px 12px';
                suggestionButton.style.background = 'var(--bg-primary)';
                suggestionButton.style.border = '1px solid var(--border-color)';
                suggestionButton.style.borderRadius = '4px';
                suggestionButton.style.cursor = 'pointer';
                suggestionButton.style.minHeight = '44px';
                suggestionButton.style.width = '100%';
                suggestionButton.style.maxWidth = '200px';
                suggestionButton.style.margin = '0';
                
                suggestionButton.innerHTML = `
                    <strong>${suggestion.name}</strong>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">${suggestion.desc}</div>
                `;
                
                suggestionButton.addEventListener('click', () => {
                    suggestion.action(key, scale);
                });
                
                suggestionList.appendChild(suggestionButton);
            });
            
            suggestionsDiv.appendChild(header);
            suggestionsDiv.appendChild(suggestionList);
            
            outputEl.appendChild(suggestionsDiv);
        }

        function updateExistingProgression(newKey) {
            const outputEl = document.getElementById('progressionOutput');
            if (!outputEl.textContent) return;
            
            const chordItems = document.querySelectorAll('.chord-item');
            if (!chordItems.length) return;
            
            const scale = document.getElementById('scale').value;
            const modes = {
                seventh: document.getElementById('seventhMode').checked,
                advanced: document.getElementById('advancedMode').checked
            };
            
            // Get all existing chord degrees for later updating the history
            const chordData = [];
            
            // Update each chord with the new key
            chordItems.forEach((item) => {
                const chordSymbolEl = item.querySelector('.chord-symbol');
                const degreeMatch = chordSymbolEl.textContent.match(/\((.*?)\)/);
                
                if (degreeMatch) {
                    const degree = degreeMatch[1];
                    const rootNote = romanToNote(degree, newKey, scale);
                    
                    // Get chord intervals based on degree and modes
                    const chordIntervals = getRomanNumeralChord(degree, scale, modes);
                    
                    // Get chord notes
                    const notes = getChordNotes(rootNote, chordIntervals);
                    
                    // Get chord name
                    const chordName = getChordName(rootNote, chordIntervals);
                    
                    // Store chord data for history
                    chordData.push({
                        degree,
                        root: rootNote,
                        notes,
                        name: chordName,
                        theoreticalContext: degree === 'V' && scale.includes('minor') ? 'harmonic minor function' : null
                    });
                    
                    // Update display
                    const chordNumber = Array.from(chordItems).indexOf(item) + 1;
                    chordSymbolEl.textContent = `Chord ${chordNumber} (${degree}): ${chordName}`;
                    
                    const chordNotesEl = item.querySelector('.chord-notes');
                    if (chordNotesEl) {
                        chordNotesEl.textContent = `Notes: ${notes.join(', ')}`;
                        
                        // Update or add theoretical context if needed
                        const theoryNoteEl = chordNotesEl.querySelector('.theory-note');
                        if (degree === 'V' && scale.includes('minor')) {
                            if (theoryNoteEl) {
                                theoryNoteEl.textContent = 'Note: harmonic minor function';
                            } else {
                                const theoryNote = document.createElement('div');
                                theoryNote.className = 'theory-note';
                                theoryNote.textContent = 'Note: harmonic minor function';
                                theoryNote.style.fontSize = "0.85em";
                                theoryNote.style.color = "var(--text-secondary)";
                                theoryNote.style.fontStyle = "italic";
                                chordNotesEl.appendChild(theoryNote);
                            }
                        } else if (theoryNoteEl) {
                            // Remove theory note if not needed
                            theoryNoteEl.remove();
                        }
                    }
                }
            });
            
            // Update the progression sequence display
            const sequenceDiv = outputEl.querySelector('.progression-sequence');
            if (sequenceDiv) {
                const newChordNames = chordData.map(chord => chord.name);
                sequenceDiv.innerHTML = `<span>${newChordNames.join(' → ')}</span>`;
            }
            
            // Update scale notes reference
            const scaleNotesRef = outputEl.querySelector('.scale-notes-reference');
            if (scaleNotesRef) {
                const scaleFormatted = scale.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                const scaleNotes = getScaleNotes(newKey, SCALES[scale]).filter(note => !note.includes('2')); // Remove octave duplicates
                
                scaleNotesRef.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px;">${newKey} ${scaleFormatted} Scale Notes:</div>
                    <div>${scaleNotes.join(' - ')}</div>
                `;
            }
            
            // Update progression info
            const progressionInfo = outputEl.querySelector('.progression-details');
            if (progressionInfo) {
                const scaleFormatted = scale.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                progressionInfo.textContent = `Key: ${newKey} ${scaleFormatted}`;
            }
            
            // Add to history
            const progressionType = document.getElementById('progressionType').value;
            saveProgressionToHistory({
                key: newKey,
                scale: scale.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
                scaleValue: scale,
                progressionType: progressionType,
                progressionName: getProgressionName(progressionType),
                chords: chordData.map(c => c.name),
                chordDetails: chordData,
                useSevenths: modes.seventh,
                useAdvanced: modes.advanced,
                chordCount: chordData.length
            });
        }

        // Initialize everything on load
        document.addEventListener('DOMContentLoaded', () => {
            initUI();
            
            // Set initial keyboard size
            window.setTimeout(() => {
                updateKeyboardZoom();
            }, 100);
            
            // Prevent double-tap zoom on iOS
            document.addEventListener('touchend', (e) => {
                if (e.target.classList.contains('key')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Add custom touch handling for keyboard
            addTouchSupport();
            
        });
        
        function addTouchSupport() {
            const keyboard = document.getElementById('keyboard');
            
            // Add pinch-to-zoom for keyboard
            let initialDistance = 0;
            let initialScale = 1;
            
            keyboard.addEventListener('touchstart', e => {
                if (e.touches.length === 2) {
                    e.preventDefault(); // Prevent default for two-finger touch
                    initialDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    initialScale = keyboardZoom;
                }
            }, { passive: false });
            
            keyboard.addEventListener('touchmove', e => {
                if (e.touches.length === 2) {
                    e.preventDefault(); // Prevent default for two-finger touch
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    
                    const scale = initialScale * (currentDistance / initialDistance);
                    keyboardZoom = Math.min(Math.max(scale, 0.6), 1.5);
                    updateKeyboardZoom();
                }
            }, { passive: false });
        }
        
        // More efficient keyboard mapping with lookup object
        const keyMap = {
            'a': 'C',
            'w': 'C#',
            's': 'D',
            'e': 'D#',
            'd': 'E',
            'f': 'F',
            't': 'F#',
            'g': 'G',
            'y': 'G#',
            'h': 'A',
            'u': 'A#',
            'j': 'B',
            // Second octave
            'k': 'C2',
            'o': 'C#2',
            'l': 'D2',
            'p': 'D#2',
            ';': 'E2',
            "'": 'F2'
        };
        
        document.addEventListener('keydown', (event) => {
            // Prevent repeated triggers while holding key
            if (event.repeat) return;
            
            // Don't handle if typing in an input or if modifiers are pressed
            if (event.target.tagName === 'INPUT' || 
                event.target.tagName === 'TEXTAREA' || 
                event.target.tagName === 'SELECT' ||
                event.ctrlKey || event.metaKey || event.altKey) {
                return;
            }
            
            const note = keyMap[event.key.toLowerCase()];
            if (note) {
                event.preventDefault(); // Prevent default behavior for note keys
                playNote(note);
                // Add visual feedback to the corresponding key
                const keyElement = document.querySelector(`[data-note="${note}"]`);
                if (keyElement) {
                    keyElement.style.transform = 'translateY(2px)';
                    keyElement.style.boxShadow = '0 0 10px var(--key-active)';
                    setTimeout(() => {
                        keyElement.style.transform = 'translateY(0)';
                        keyElement.style.boxShadow = 'none';
                    }, 150);
                }
            }
        });
        
        // Function to detect and handle devices with high pixel density
        function handleHighDPIDevices() {
            if (window.devicePixelRatio > 1) {
                // Add styles or classes for high DPI devices
                document.body.classList.add('high-dpi');
                
                // Adjust keyboard for better touch targets on high DPI
                if (window.innerWidth < 768) {
                    const keys = document.querySelectorAll('.key');
                    keys.forEach(key => {
                        if (key.classList.contains('black')) {
                            key.style.width = '18px';
                        } else {
                            key.style.width = '32px';
                        }
                    });
                }
            }
        }

        window.addEventListener('resize', function() {
            // Debounce resize events to prevent performance issues
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(() => {
                // Completely rebuild keyboard on resize for proper responsive layout
                if (document.querySelectorAll('.key').length > 0) {
                    createKeyboard();
                    updateKeyboard();
                    // Update zoom after keyboard is rebuilt
                    setTimeout(updateKeyboardZoom, 50);
                }
                
                // If progression is generated, ensure proper layout
                if (document.getElementById('progressionOutput').textContent.trim() !== '') {
                    const tabButton = document.querySelector('.tab-button[data-tab="keyboard"]');
                    if (tabButton && !tabButton.classList.contains('active')) {
                        // If not on keyboard tab, ensure keyboard tab is properly sized when returned to
                        document.getElementById('keyboard').style.width = '100%';
                    }
                }
            }, 200);
        });
        
        // Call once on load
        window.addEventListener('load', handleHighDPIDevices);
        // Also call on orientation change which may affect layout needs
        window.addEventListener('orientationchange', handleHighDPIDevices);
        
        // Service worker for offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Create service worker code as a blob
                const swCode = `
                    // Service Worker for Mabel's Theory
                    const CACHE_NAME = 'mabels-theory-v1';
                    
                    // Cache all necessary assets on install
                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME).then(cache => {
                                return cache.addAll([
                                    './',
                                    './index.html'
                                ]);
                            })
                        );
                        // Activate immediately
                        self.skipWaiting();
                    });
                    
                    // Clean up old caches on activation
                    self.addEventListener('activate', event => {
                        event.waitUntil(
                            caches.keys().then(cacheNames => {
                                return Promise.all(
                                    cacheNames.filter(cacheName => {
                                        return cacheName !== CACHE_NAME;
                                    }).map(cacheName => {
                                        return caches.delete(cacheName);
                                    })
                                );
                            })
                        );
                        // Take control of all clients immediately
                        self.clients.claim();
                    });
                    
                    // Serve from cache, falling back to network
                    self.addEventListener('fetch', event => {
                        event.respondWith(
                            caches.match(event.request).then(response => {
                                // Return cached response if found
                                if (response) {
                                    return response;
                                }
                                
                                // Otherwise try fetching from network
                                return fetch(event.request).then(networkResponse => {
                                    // Don't cache responses from other origins
                                    if (!event.request.url.startsWith(self.location.origin)) {
                                        return networkResponse;
                                    }
                                    
                                    // Clone the response before returning it
                                    const responseToCache = networkResponse.clone();
                                    
                                    caches.open(CACHE_NAME).then(cache => {
                                        cache.put(event.request, responseToCache);
                                    });
                                    
                                    return networkResponse;
                                });
                            }).catch(() => {
                                // Return a fallback for HTML pages if both cache and network fail
                                if (event.request.headers.get('accept').includes('text/html')) {
                                    return caches.match('./index.html');
                                }
                            })
                        );
                    });
                `;
                
                // Create a blob URL for the service worker
                const blob = new Blob([swCode], {type: 'application/javascript'});
                const swURL = URL.createObjectURL(blob);
                
                // Register the service worker from the blob URL
                navigator.serviceWorker.register(swURL)
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('ServiceWorker registration failed:', error);
                    });
            });
        }

        // PWA installation logic
        let deferredPrompt;
        const installBtn = document.getElementById('installBtn');

        // Listen for the beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            // Show the install button
            installBtn.style.display = 'flex';
        });

        // Installation button click handler
        installBtn.addEventListener('click', async () => {
            if (!deferredPrompt) {
                // The deferred prompt isn't available
                return;
            }
            // Show the install prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`User response to the install prompt: ${outcome}`);
            // We've used the prompt, and can't use it again, so clear it
            deferredPrompt = null;
            // Hide the install button
            installBtn.style.display = 'none';
        });

        // Listen for successful installation
        window.addEventListener('appinstalled', (evt) => {
            // Log install to analytics
            console.log('App was installed');
            // Hide the install button
            installBtn.style.display = 'none';
        });

        // Check if already installed
        if (window.matchMedia('(display-mode: standalone)').matches ||
            window.navigator.standalone === true) {
            // App is installed and running standalone
            installBtn.style.display = 'none';
        }
    </script>
</body>
</html>
